grammar Math extends de.monticore.lang.montiarc.Common2, de.monticore.lang.montiarc.SI {
    MathCompilationUnit =
      ("package" package:(Name& || ".")+ ";")?
      (ImportStatement)* // to import later on other scripts/functions
      MathScript;

    // here the script name is concretely given (in contrast to Matlab), b/c otherwise we would get
    // trouble when embedding this language into another one (due to the name-based nature of the MontiCore 4 symboltable)
    MathScript@! = "script" scriptName:Name& (MathStatement)+ "end";

    MathStatement = ConditionalStatement
                  | Assignment
                  | forStatement:ForStatement2
                  | MathExpression;

    Assignment@! = type:AssignmentType name:Name& (assignmentOp:"=" MathExpression)? ";"
                 | (Name&|MatrixName)
                        (assignmentOp:"=" | assignmentOp:"+=" | assignmentOp:"-=" | assignmentOp:"*=" | assignmentOp:"/=")
                        MathExpression ";"
                 ;


        ConditionalStatement = IfStatement2 (ElseIfStatement2)* (ElseStatement2)? "end" | BooleanExpression "?" (m1:MathStatement)+ ":" (m2:MathStatement)+;

        IfStatement2 = "if"  BooleanExpression "{" (MathStatement)+ "}";
        ElseIfStatement2 = "elseif"  BooleanExpression "{" (MathStatement)+ "}";
        ElseStatement2 = "else" "{"(MathStatement)+ "}";

    ForStatement2 = "for" forAssignment:ForAssignment2
                        (MathStatement)+
                   "end";

    ForAssignment2 = name:Name& "=" MathExpression;

     // Q for rational numbers, C for complex numbers where real and imaginary part have same unit kind
    AssignmentType = matrixProperty:Name* ElementType dim:Dimension?;

    // since Q(1 : 7) would conflict with with vector expression, we need to define
    // it as token, and then parse the token later on
    // this due to the fact that MC4 does not support island grammars such as Antlr4
    ElementType = TElementType |
                 [isWholeNumber:"Z"] |
                 [isRational:"Q"] |
                 [isComplex:"C"] |
                 [isBoolean:"B"];

    token TElementType =
      ('Z' | 'Q' | 'C') Space*
        '(' Space* (TUnitNumber | TUnitInf) Space* ':'
            (Space* TUnitNumber Space* ':')?
            Space* (TUnitNumber | TUnitInf) Space*
        ')';

    // ast of ElementType will be now manually constructed as it would be when MC4 would
    // read the following definition:
    /*
    ElementType =
     (([isWholeNumber:"Z"] | [isRational:"Q"] | [isComplex:"C"]) range:Range?) |
     [isBoolean:"B"];
    */

    Dimension = "^" "{" (ArithmeticExpression || ",")+ "}";

    MathExpression = ArithmeticExpression
                   | ArithmeticMatrixExpression
                   | BooleanExpression;

    MathPrimaryExpression = Number
                      | Name&
                      | MatrixName;

    ArithmeticMatrixExpression = PlusMinusMatrixExpression;

    PlusMinusMatrixExpression = MultSolMatrixExpression  PlusMinusMatrixHelpExpression;
    PlusMinusMatrixHelpExpression = (additiveOp:"+" | additiveOp:"-") MultSolMatrixExpression PlusMinusMatrixHelpExpression
                                  |;

    MultSolMatrixExpression = UnaryAritMatrixExpression MultSolMatrixHelpExpression;
    MultSolMatrixHelpExpression = (muldivOp:"*" | muldivOp:".*" | muldivOp:"./" | muldivOp:"\\\\") UnaryAritMatrixExpression MultSolMatrixHelpExpression
                                |;

    UnaryAritMatrixExpression = (unaryaritOp:"-" | unaryaritOp:"+") TransposeMatrixExpression
                              | TransposeMatrixExpression;

    TransposeMatrixExpression = ParenthesisMatrixExpression (transposeOp:"\'")
                              | ParenthesisMatrixExpression (powOp:"^" | powOp:".^") ArithmeticExpression
                              | ParenthesisMatrixExpression;

    ParenthesisMatrixExpression = "(" ArithmeticMatrixExpression ")"
                                | Matrix | Name&;

    ArithmeticExpression = PlusMinusExpression;

    PlusMinusExpression = MultDivModExpression PlusMinusHelpExpression;
    PlusMinusHelpExpression = (additiveOp:"+" | additiveOp:"-") MultDivModExpression PlusMinusHelpExpression
                            |;

    MultDivModExpression = UnaryOpExpression MultDivModHelpExpression;
    MultDivModHelpExpression = (muldivOp:"*" | muldivOp:"/" | muldivOp:"%") UnaryOpExpression MultDivModHelpExpression
                             |;

    UnaryOpExpression = ParenthesisAritExpression (unaryOp:"++" | unaryOp:"--" | transposeOp:"\'")
                      | (unaryOp:"++" | unaryOp:"--") ParenthesisAritExpression
                      | "(" Type ")" ParenthesisAritExpression
                      | ParenthesisAritExpression powOp:"^" ArithmeticExpression
                      | ParenthesisAritExpression;

    ParenthesisAritExpression = "(" ArithmeticExpression ")"
                              | MathPrimaryExpression;

    BooleanExpression =  LogicalOrExpression;

    LogicalOrExpression = LogicalAndExpression LogicalOrHelpExpression;
    LogicalOrHelpExpression = or:"||" LogicalAndExpression LogicalOrHelpExpression
                                |;

    LogicalAndExpression = LogicalEqualsExpression LogicalAndHelpExpression;
    LogicalAndHelpExpression = and:"&&" LogicalEqualsExpression LogicalAndHelpExpression
                                 |;

    LogicalEqualsExpression = LogicalCompareExpression LogicalEqualsHelpExpression;
    LogicalEqualsHelpExpression = equalsOp:"==" LogicalCompareExpression LogicalEqualsHelpExpression
                                    | equalsOp:"!=" LogicalCompareExpression LogicalEqualsHelpExpression
                                    |;

    LogicalCompareExpression = LogicalParenthesisExpression LogicalCompareHelpExpression;
    LogicalCompareHelpExpression = compareOp:">" LogicalParenthesisExpression LogicalCompareHelpExpression
                                     | compareOp:">=" LogicalParenthesisExpression LogicalCompareHelpExpression
                                     | compareOp:"<" LogicalParenthesisExpression LogicalCompareHelpExpression
                                     | compareOp:"<=" LogicalParenthesisExpression LogicalCompareHelpExpression
                                     |;

    LogicalParenthesisExpression = "(" BooleanExpression ")"
                                     | ArithmeticExpression;

    Matrix = "[" (VectorInner || ";")* "]" | Vector;
    MatrixName = Name& "(" VectorInner ")" | Name& "(" Endoperator ")";

    //supports only 2D matrices
    Endoperator = ":" "," EndVecRight | EndVecLeft ","  ":" | EndVecLeft "," EndVecRight | EndVec ;
    EndVecRight = EndVec;
    EndVecLeft = EndVec;
    EndVec =  ArithmeticExpression (":" ArithmeticExpression (":" ArithmeticExpression)?)?;

    Vector = ArithmeticExpression ":" ArithmeticExpression (":" ArithmeticExpression)?;
    VectorInner = ArithmeticExpression ((",")? ArithmeticExpression)*;
}
