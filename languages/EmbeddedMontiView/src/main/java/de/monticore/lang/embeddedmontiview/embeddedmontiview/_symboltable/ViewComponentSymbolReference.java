/* (c) https://github.com/MontiCore/monticore */
/* generated from model null*/
/* generated by template symboltable.SymbolReference*/

package de.monticore.lang.embeddedmontiview.embeddedmontiview._symboltable;

import com.google.common.collect.ImmutableList;
import de.monticore.lang.monticar.si._symboltable.ResolutionDeclarationSymbol;
import de.monticore.lang.monticar.types2._ast.ASTUnitNumberResolution;
import de.monticore.symboltable.MutableScope;
import de.monticore.symboltable.Scope;
import de.monticore.symboltable.modifiers.AccessModifier;
import de.monticore.symboltable.references.CommonSymbolReference;
import de.monticore.symboltable.references.SymbolReference;
import de.monticore.symboltable.types.references.ActualTypeArgument;
import de.se_rwth.commons.logging.Log;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Represents a reference of {@link ViewComponentSymbol}.
 */
public class ViewComponentSymbolReference extends ViewComponentSymbol
    implements SymbolReference<ViewComponentSymbol> {

  protected final SymbolReference<ViewComponentSymbol> reference;
  private List<ActualTypeArgument> actualTypeArguments = new ArrayList<>();

  public ViewComponentSymbolReference(final String name, final Scope definingScopeOfReference) {
    super(name);
    reference = new CommonSymbolReference<>(name, ViewComponentSymbol.KIND, definingScopeOfReference);
    if (existsReferencedSymbol()) {
      setReferencedComponent(Optional.of(getReferencedSymbol()));

    }

  }

  public ViewComponentSymbolReference(final String name, final Scope definingScopeOfReference, EmbeddedMontiViewSymbolTableCreator emastc) {
    super(name);
    reference = new CommonSymbolReference<>(name, ViewComponentSymbol.KIND, definingScopeOfReference);
    if (existsReferencedSymbol()) {
      Log.debug("Loading resolution declarationSymbols", "info");
      setReferencedComponent(Optional.of(getReferencedSymbol()));
      this.getResolutionDeclarationSymbols().addAll(reference.getReferencedSymbol().getResolutionDeclarationSymbols());

    }
    else {
      Log.debug("Reference to " + name + " does not exist", "info");

    }

  }

  public void fixResolutions(EmbeddedMontiViewSymbolTableCreator emastc) {

    int count = 0;
    for (ResolutionDeclarationSymbol resDeclSym : getResolutionDeclarationSymbols()) {
      Log.debug("" + ((ASTUnitNumberResolution) getResolutionDeclarationSymbols().get(count).getASTResolution()).getNumber().get().intValue(), "resolus:");
      String lastNameStart = "";
      for (ViewPortSymbol viewPortSymbol : getIncomingPorts()) {
        Log.debug(viewPortSymbol.getName(), "Found Port:");
        if (!viewPortSymbol.getNameWithoutArrayBracketPart().equals(lastNameStart)) {
          lastNameStart = viewPortSymbol.getNameWithoutArrayBracketPart();
          Log.debug(lastNameStart, "Found PortArray:");
          Log.debug(viewPortSymbol.getEnclosingScope().toString(), "PortArray enclosing scope:");
          ViewPortArraySymbol viewPortArraySymbol = viewPortSymbol.getEnclosingScope().<ViewPortArraySymbol>resolve(lastNameStart, ViewPortArraySymbol.KIND).get();
          viewPortArraySymbol.recreatePortArray(resDeclSym, emastc, this);
        }
      }
    }

    Log.debug("" + getIncomingPorts().size(), "incoming:");

    Log.debug("" + getOutgoingPorts().size(), "outgoing:");
  }

  public List<ActualTypeArgument> getActualTypeArguments() {
    return ImmutableList.copyOf(actualTypeArguments);
  }

  public void setActualTypeArguments(List<ActualTypeArgument> actualTypeArguments) {
    this.actualTypeArguments = new ArrayList<>(actualTypeArguments);
  }

  public boolean hasActualTypeArguments() {
    return this.actualTypeArguments.size() > 0;
  }

  // no overridden methods of ViewComponentSymbol as the ViewComponentSymbol itself checks whether it is a
  // reference or not.
  
  /* Methods of SymbolReference interface */

  @Override
  public ViewComponentSymbol getReferencedSymbol() {
    return reference.getReferencedSymbol();
  }

  @Override
  public boolean existsReferencedSymbol() {
    return reference.existsReferencedSymbol();
  }

  @Override
  public boolean isReferencedSymbolLoaded() {
    return reference.isReferencedSymbolLoaded();
  }
  
  /* Methods of Symbol interface */

  @Override
  public String getName() {
    return getReferencedSymbol().getName();
  }

  @Override
  public String getFullName() {
    return getReferencedSymbol().getFullName();
  }

  @Override
  public Scope getEnclosingScope() {
    return getReferencedSymbol().getEnclosingScope();
  }

  @Override
  public void setEnclosingScope(MutableScope scope) {
    getReferencedSymbol().setEnclosingScope(scope);
  }

  @Override
  public AccessModifier getAccessModifier() {
    return getReferencedSymbol().getAccessModifier();
  }

  @Override
  public void setAccessModifier(AccessModifier accessModifier) {
    getReferencedSymbol().setAccessModifier(accessModifier);
  }

}
