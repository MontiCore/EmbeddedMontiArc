/* (c) https://github.com/MontiCore/monticore */
package de.rwth.wei.modeling.autopilot.collisionavoidanceService;

component Collisioninformation{
    // to find the collision point, based on the vehicle boundary model (on the trajectory)
    // collision should near to the intersection point
    ports
    //current vehicle
    in  Z            trajectory_length,
    in  Q^{1,100}    trajectory_x,
    in  Q^{1,100}    trajectory_y,
    in  Q            length,
    in  Q            width,
    // next intersection to current
    in  Q            nextintersection_x,
    in  Q            nextintersection_y,
    // other vehicle
    // from the trajctory message
    in Z             trajectory_length_car1,
    in Q^{1,100}     trajectory_x_car1,
    in Q^{1,100}     trajectory_y_car1,
    in Q             car1_nextintersection_x,
    in Q             car1_nextintersection_y,
    // from the status message
    in Q             car1_position_x,
    in Q             car1_position_y,
    in Q             car1_length,
    in Q             car1_width,
    in Z             car1_id,
    in Q             car1_velocity,

    out Z iscollision,
    out Z collsion_id,
    out Q velocity_car1,
    out Q dis2intersection_car1,
    out Q angletocurrent,
    out Z proritytocurrent;

    implementation Math{
        Z firstcollision = 0;
        Q collison_point_x = 0.0;
        Q collison_point_y = 0.0;
        Q collison_point_x_car1 = 0.0;
        Q collison_point_y_car1 = 0.0;
        iscollision = 0;
        collsion_id = car1_id;
        velocity_car1 = car1_velocity;
        Q sqrtdis10 = (car1_position_x - car1_nextintersection_x)*(car1_position_x - car1_nextintersection_x) + (car1_position_y - car1_nextintersection_y)*(car1_position_y - car1_nextintersection_y);
        dis2intersection_car1 = sqrt(sqrtdis10);
        angletocurrent = 0.0;
        proritytocurrent = 0.0;

        Q max_diag_1x = 0.0;
        Q max_diag_1y = 0.0;
        Q min_diag_1x = 0.0;
        Q min_diag_1y = 0.0;
        Q max_diag_2x = 0.0;
        Q max_diag_2y = 0.0;
        Q min_diag_2x = 0.0;
        Q min_diag_2y = 0.0;
        Q max_diag_car1_1x = 0.0;
        Q max_diag_car1_1y = 0.0;
        Q min_diag_car1_1x = 0.0;
        Q min_diag_car1_1y = 0.0;
        Q max_diag_car1_2x = 0.0;
        Q max_diag_car1_2y = 0.0;
        Q min_diag_car1_2x = 0.0;
        Q min_diag_car1_2y = 0.0;
        Q max_car1_1x = 0.0;
        Q max_car1_1y = 0.0;
        Q min_car1_1x = 0.0;
        Q min_car1_1y = 0.0;
        Q max_car1_2x = 0.0;
        Q max_car1_2y = 0.0;
        Q min_car1_2x = 0.0;
        Q min_car1_2y = 0.0;
        Q max_car1_3x = 0.0;
        Q max_car1_3y = 0.0;
        Q min_car1_3x = 0.0;
        Q min_car1_3y = 0.0;
        Q max_car1_4x = 0.0;
        Q max_car1_4y = 0.0;
        Q min_car1_4x = 0.0;
        Q min_car1_4y = 0.0;
        Q max_1x = 0.0;
        Q max_1y = 0.0;
        Q min_1x = 0.0;
        Q min_1y = 0.0;
        Q max_2x = 0.0;
        Q max_2y = 0.0;
        Q min_2x = 0.0;
        Q min_2y = 0.0;
        Q max_3x = 0.0;
        Q max_3y = 0.0;
        Q min_3x = 0.0;
        Q min_3y = 0.0;
        Q max_4x = 0.0;
        Q max_4y = 0.0;
        Q min_4x = 0.0;
        Q min_4y = 0.0;

        for i= 1:(trajectory_length-1)
          // current position and next position
          Q px = trajectory_x(1,i);
          Q px1 = trajectory_x(1,i+1);
          Q py = trajectory_y(1,i);
          Q py1 = trajectory_y(1,i+1);
          Q vpx = px1 - px;
          Q vpy = py1 - py;
          Q model11 = vpx * vpx + vpy * vpy;
          Q model22 = sqrt(model11);
          Q rads = acos(vpx/model22);
          // originial position of Boundary box
          Q top_rightx =  0.0;
          Q top_righty =  0.0;
          Q top_leftx =  0.0;
          Q top_lefty =  0.0;
          Q bottom_rightx = 0.0;
          Q bottom_righty =  0.0;
          Q bottom_leftx =  0.0;
          Q bottom_lefty =  0.0;

          Q top_rightx0 = px + length/2;
          Q top_righty0 = py - width/2;
          Q top_leftx0 = px + length/2;
          Q top_lefty0 = py + width/2;
          Q bottom_rightx0 = px -length/2;
          Q bottom_righty0 = py - width/2;
          Q bottom_leftx0 = px -length/2;
          Q bottom_lefty0 = py + width/2;

          if (vpx == 0) || (vpy == 0)
            if (vpx == 0)&&(vpy < 0)
              top_rightx = px - width/2;
              top_righty = py - length/2;
              top_leftx = px + width/2;
              top_lefty = py - length/2;
              bottom_rightx = px - width/2;
              bottom_righty = py + length/2;
              bottom_leftx = px + width/2;
              bottom_lefty = py + length/2;
            end
            if (vpx == 0)&&(vpy > 0)
              top_rightx = px + width/2;
              top_righty = py + length/2;
              top_leftx = px - width/2;
              top_lefty = py + length/2;
              bottom_rightx = px + width/2;
              bottom_righty = py - length/2;
              bottom_leftx = px - width/2;
              bottom_lefty = py - length/2;
            end
            if (vpx < 0)&&(vpy == 0)
              top_rightx = top_rightx0;
              top_righty = top_righty0;
              top_leftx = top_leftx0;
              top_lefty = top_lefty0;
              bottom_rightx = bottom_rightx0;
              bottom_righty = bottom_righty0;
              bottom_leftx = bottom_leftx0;
              bottom_lefty = bottom_lefty0;
            end
            if (vpx > 0)&&(vpy == 0)
              top_rightx = bottom_leftx0;
              top_righty = bottom_lefty0;
              top_leftx = bottom_rightx0;
              top_lefty = bottom_righty0;
              bottom_rightx = top_leftx0;
              bottom_righty = top_lefty0;
              bottom_leftx = top_rightx0;
              bottom_lefty = top_righty0;
            end
          end
          if(vpx < 0 && vpy > 0)||(vpx < 0 && vpy < 0)
            top_rightx = (top_rightx0 - px)*cos(M_PI + rads) - (top_righty0 - py)*sin(M_PI + rads) + px;
            top_righty = (top_rightx0 - px)*sin(M_PI + rads) + (top_righty0 - py)*cos(M_PI + rads) + py;
            top_leftx = (top_leftx0 - px)*cos(M_PI + rads)- (top_lefty0 - py)*sin(M_PI + rads) +px;
            top_lefty = (top_leftx0 - px)*sin(M_PI + rads) + (top_lefty0 - py)*cos(M_PI + rads) +py;
            bottom_rightx = (bottom_rightx0 - px)*cos(M_PI + rads) - (bottom_righty0 - py)*sin(M_PI + rads) +px;
            bottom_righty = (bottom_rightx0 - px)*sin(M_PI + rads) + (bottom_righty0 - py)*cos(M_PI + rads) +py;
            bottom_leftx = (bottom_leftx0 - px)*cos(M_PI + rads) - (bottom_lefty0 - py)*sin(M_PI + rads) +px;
            bottom_lefty = (bottom_leftx0 - px)*sin(M_PI + rads) + (bottom_lefty0 - py)*cos(M_PI + rads) +py;
          else
            top_rightx = (top_rightx0 - px)*cos(rads) - (top_righty0 - py)*sin(rads) + px;
            top_righty = (top_rightx0 - px)*sin(rads) + (top_righty0 - py)*cos(rads) + py;
            top_leftx = (top_leftx0 - px)*cos(rads)- (top_lefty0 - py)*sin(rads) + px;
            top_lefty = (top_leftx0 - px)*sin(rads) + (top_leftx0 - py)*cos(rads) + py;
            bottom_rightx = (bottom_rightx0 - px)*cos(rads) - (bottom_righty0 - py)*sin(rads) + px;
            bottom_righty = (bottom_rightx0 - px)*sin(rads) +(bottom_righty0 - py)*cos(rads) + py;
            bottom_leftx = (bottom_leftx0 - px)*cos(rads) - (bottom_lefty0 - py)*sin(rads) + px;
            bottom_lefty = (bottom_leftx0 - px)*sin(rads) +(bottom_lefty0 - py)*cos(rads) + py;
          end
          for j = 1:(trajectory_length_car1-1)
              // current position and next position
              Q px_car1 = trajectory_x_car1(1,j);
              Q px1_car1 = trajectory_x_car1(1,j+1);
              Q py_car1 = trajectory_y_car1(1,j);
              Q py1_car1 = trajectory_y_car1(1,j+1);
              Q vpx_car1 = px1_car1 - px_car1;
              Q vpy_car1 = py1_car1 - py_car1;
              Q rads_car1 = atan(vpx_car1/vpy_car1);

              // originial position of Boundary box
              Q top_rightx_car1 = 0.0;
              Q top_righty_car1 = 0.0;
              Q top_leftx_car1 = 0.0;
              Q top_lefty_car1 = 0.0;
              Q bottom_rightx_car1 = 0.0;
              Q bottom_righty_car1 = 0.0;
              Q bottom_leftx_car1 = 0.0;
              Q bottom_lefty_car1 = 0.0;

              Q top_rightx0_car1 = px_car1 - car1_width/2;
              Q top_righty0_car1 = py_car1 - car1_length/2;
              Q top_leftx0_car1 = px_car1 + car1_width/2;
              Q top_lefty0_car1 = py_car1 - car1_length/2;
              Q bottom_rightx0_car1 = px_car1 - car1_width/2;
              Q bottom_righty0_car1 = py_car1 + car1_length/2;
              Q bottom_leftx0_car1 = px_car1 + car1_width/2;
              Q bottom_lefty0_car1 = py_car1 + car1_length/2;
              if (vpx_car1 == 0) || (vpy_car1 == 0)
                if (vpx == 0)&&(vpy < 0)
                  top_rightx_car1 = px_car1 - car1_width/2;
                  top_righty_car1 = py_car1 - car1_length/2;
                  top_leftx_car1 = px_car1 + car1_width/2;
                  top_lefty_car1 = py_car1 - car1_length/2;
                  bottom_rightx_car1 = px_car1 - car1_width/2;
                  bottom_righty_car1 = py_car1 + car1_length/2;
                  bottom_leftx_car1 = px_car1 + car1_width/2;
                  bottom_lefty_car1 = py_car1 + car1_length/2;
                end
                if (vpx == 0)&&(vpy > 0)
                  top_rightx_car1 = px_car1 + car1_width/2;
                  top_righty_car1 = py_car1 + car1_length/2;
                  top_leftx_car1 = px_car1 - car1_width/2;
                  top_lefty_car1 = py_car1 + car1_length/2;
                  bottom_rightx_car1 = px_car1 + car1_width/2;
                  bottom_righty_car1 = py_car1 - car1_length/2;
                  bottom_leftx_car1 = px_car1 - car1_width/2;
                  bottom_lefty_car1 = py_car1 - car1_length/2;
                end
                if (vpx < 0)&&(vpy == 0)
                  top_rightx_car1 = top_rightx0_car1;
                  top_righty_car1 = top_righty0_car1;
                  top_leftx_car1 = top_leftx0_car1;
                  top_lefty_car1 = top_lefty0_car1;
                  bottom_rightx_car1 = bottom_rightx0_car1;
                  bottom_righty_car1 = bottom_righty0_car1;
                  bottom_leftx_car1 = bottom_leftx0_car1;
                  bottom_lefty_car1 = bottom_lefty0_car1;
                end
                if (vpx > 0)&&(vpy == 0)
                  top_rightx_car1 = bottom_leftx0_car1;
                  top_righty_car1 = bottom_lefty0_car1;
                  top_leftx = bottom_rightx0_car1;
                  top_lefty = bottom_righty0_car1;
                  bottom_rightx = top_leftx0_car1;
                  bottom_righty = top_lefty0_car1;
                  bottom_leftx = top_rightx0_car1;
                  bottom_lefty = top_righty0_car1;
                end
              end
              if(vpx < 0 && vpy > 0)||(vpx < 0 && vpy < 0)
                top_rightx_car1 = (top_rightx0_car1 - px_car1)*cos(M_PI + rads_car1) - (top_righty0_car1 - py_car1)*sin(M_PI + rads_car1) + px_car1;
                top_righty_car1 = (top_rightx0_car1 - px_car1)*sin(M_PI + rads_car1) +(top_righty0_car1 - py_car1)*cos(M_PI + rads_car1) + py_car1;
                top_leftx_car1 = (top_leftx0_car1 - px_car1)*cos(M_PI + rads_car1) - (top_lefty0_car1 - py_car1)*sin(M_PI + rads_car1) + px_car1;
                top_lefty_car1 = (top_leftx0_car1 - px_car1)*sin(M_PI + rads_car1) +(top_lefty0_car1 - py_car1)*cos(M_PI + rads_car1) + py_car1;
                bottom_rightx_car1 = (bottom_rightx0_car1 - px_car1)*cos(M_PI + rads_car1) - (bottom_righty0_car1 - py_car1)*sin(M_PI + rads_car1) +px_car1;
                bottom_righty_car1 = (bottom_rightx0_car1 - px_car1)*sin(M_PI + rads_car1) +(bottom_righty0_car1 - py_car1)*cos(M_PI + rads_car1) +py_car1;
                bottom_leftx_car1 = (bottom_leftx0_car1 - px_car1)*cos(M_PI + rads_car1) - (bottom_lefty0_car1 - py_car1)*sin(M_PI + rads_car1) +px_car1;
                bottom_lefty_car1 = (bottom_leftx0_car1 - px_car1)*sin(M_PI + rads_car1) +(bottom_lefty0_car1 - py_car1)*cos(M_PI + rads_car1) +py_car1;
              else
                top_rightx_car1 = (top_rightx0_car1 - px_car1)*cos(rads_car1) - (top_righty0_car1 - py_car1)*sin(rads_car1) +px_car1;
                top_righty_car1 = (top_rightx0_car1 - px_car1)*sin(rads_car1) +(top_righty0_car1 - py_car1)*cos(rads_car1) +py_car1;
                top_leftx_car1 = (top_leftx0_car1 - px_car1)*cos(rads_car1) - (top_lefty0_car1 - py_car1)*sin(rads_car1) +px_car1;
                top_lefty_car1 = (top_leftx0_car1 - px_car1)*sin(rads_car1) +(top_leftx0_car1 - py_car1)*cos(rads_car1) +py_car1;
                bottom_rightx_car1 = (bottom_rightx0_car1 - px_car1)*cos(rads_car1) - (bottom_righty0_car1 - py_car1)*sin(rads_car1) +px_car1;
                bottom_righty_car1 = (bottom_rightx0_car1 - px_car1)*sin(rads_car1) +(bottom_righty0_car1 - py_car1)*cos(rads_car1) +py_car1;
                bottom_leftx_car1 = (bottom_leftx0_car1 - px_car1)*cos(rads_car1) - (bottom_lefty0_car1 - py_car1)*sin(rads_car1) +px_car1;
                bottom_lefty_car1 = (bottom_leftx0_car1 - px_car1)*sin(rads_car1) +(bottom_lefty0_car1 - py_car1)*cos(rads_car1) +py_car1;
              end
              Q center_distance_sqrt = (px - px_car1)*(px - px_car1)+(py - py_car1)*(py - py_car1);
              Q center_dis = sqrt(center_distance_sqrt);
              //frist judgement of Boundary collsion
              if (center_dis < width/2 + car1_width/2) && (firstcollision == 0)
                firstcollision = 1;
                iscollision = 1;
                collsion_id = car1_id;
                collison_point_x = trajectory_x(1,i);
                collison_point_y = trajectory_y(1,i);
                collison_point_x_car1 = trajectory_x_car1(1,j);
                collison_point_y_car1 = trajectory_y_car1(1,j);
              else
                // first diag line of current vehicle(Top R to bottom L)
                // x-ray
                if top_rightx - bottom_leftx > 0
                  max_diag_1x = top_rightx;
                  min_diag_1x = bottom_leftx;
                else
                  max_diag_1x = bottom_leftx;
                  min_diag_1x = top_rightx;
                end
                // y-ray
                if top_righty - bottom_lefty > 0
                  max_diag_1y = top_righty;
                  min_diag_1y = bottom_lefty;
                else
                  max_diag_1y = bottom_lefty;
                  min_diag_1y = top_righty;
                end
                // second diag line of current vehicle(Top L to bottom R)
                // x-ray
                if top_leftx - bottom_rightx > 0
                  max_diag_2x = top_leftx;
                  min_diag_2x = bottom_rightx;
                else
                  max_diag_2x = bottom_rightx;
                  min_diag_2x = top_leftx;
                end
                // y-ray
                if top_lefty - bottom_righty > 0
                  max_diag_2y = top_lefty;
                  min_diag_2y = bottom_righty;
                else
                  max_diag_2y = bottom_righty;
                  min_diag_2y = top_lefty;
                end

                // Boundary line 1 of car 1(top to bottom R)
                // x-ray
                if top_rightx_car1 - bottom_rightx_car1 > 0
                  max_car1_1x = top_rightx_car1;
                  min_car1_1x = bottom_rightx_car1;
                else
                  max_car1_1x = bottom_rightx_car1;
                  min_car1_1x = top_rightx_car1;
                end
                // y-ray
                if top_righty_car1 - bottom_righty_car1 > 0
                  max_car1_1y = top_righty_car1;
                  min_car1_1y = bottom_righty_car1;
                else
                  max_car1_1y = bottom_righty_car1;
                  min_car1_1y = top_righty_car1;
                end
                // if there is a collision between diag line 1 of current vehicle and boundary line 1 of car 1
                // first step: Rapid rejection test
                if ( max_diag_1x >= min_car1_1x )&&( max_car1_1x >= min_diag_1x )&&( max_diag_1y >= min_car1_1y )&&( max_car1_1y >= min_diag_1y)
                  Q P1Q1_x = top_rightx - top_rightx_car1;
                  Q P1Q1_y = top_righty - top_righty_car1;
                  Q Q2Q1_x = bottom_rightx_car1 - top_rightx_car1;
                  Q Q2Q1_y = bottom_righty_car1 - top_righty_car1;
                  Q P2Q1_x = bottom_leftx - top_rightx_car1;
                  Q P2Q1_y = bottom_lefty - top_righty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  // second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of current vehicle and boundary line 1 of car 1
                // first step: Rapid rejection test
                if ( max_diag_2x >= min_car1_1x )&&( max_car1_1x >= min_diag_2x )&&( max_diag_2y >= min_car1_1y )&&( max_car1_1y >= min_diag_2y)
                  Q P1Q1_x = top_leftx - top_rightx_car1;
                  Q P1Q1_y = top_lefty - top_righty_car1;
                  Q Q2Q1_x = bottom_rightx_car1 - top_rightx_car1;
                  Q Q2Q1_y = bottom_righty_car1 - top_righty_car1;
                  Q P2Q1_x = bottom_rightx - top_rightx_car1;
                  Q P2Q1_y = bottom_righty - top_righty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end

                // Boundary line 2 of car 1 (R to L top)
                // x-ray
                if top_rightx_car1 - top_leftx_car1 > 0
                  max_car1_2x = top_rightx_car1;
                  min_car1_2x = top_leftx_car1;
                else
                  max_car1_2x = top_leftx_car1;
                  min_car1_2x = top_rightx_car1;
                end
                // y-ray
                if top_righty_car1 - top_lefty_car1 > 0
                  max_car1_2y = top_righty_car1;
                  min_car1_2y = top_lefty_car1;
                else
                  max_car1_2y = top_lefty_car1;
                  min_car1_2y = top_righty_car1;
                end
                // if there is a collision between diag line 1 of current vehicle and boundary line 2 of car 1
                // first step: Rapid rejection test
                if ( max_diag_1x >= min_car1_2x )&&( max_car1_2x >= min_diag_1x )&&( max_diag_1y >= min_car1_2y )&&( max_car1_2y >= min_diag_1y)
                  Q P1Q1_x = top_rightx - top_rightx_car1;
                  Q P1Q1_y = top_righty - top_righty_car1;
                  Q Q2Q1_x = top_leftx_car1 - top_rightx_car1;
                  Q Q2Q1_y = top_lefty_car1 - top_righty_car1;
                  Q P2Q1_x = bottom_leftx - top_rightx_car1;
                  Q P2Q1_y = bottom_lefty - top_righty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of current vehicle and boundary line 2 of car 1
                // first step: Rapid rejection test
                if ( max_diag_2x >= min_car1_2x )&&( max_car1_2x >= min_diag_2x )&&( max_diag_2y >= min_car1_2y )&&( max_car1_2y >= min_diag_2y)
                  Q P1Q1_x = top_leftx - top_rightx_car1;
                  Q P1Q1_y = top_lefty - top_righty_car1;
                  Q Q2Q1_x = bottom_rightx_car1 - top_rightx_car1;
                  Q Q2Q1_y = bottom_righty_car1 - top_righty_car1;
                  Q P2Q1_x = bottom_rightx - top_rightx_car1;
                  Q P2Q1_y = bottom_righty - top_righty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end

                // Boundary line 3 of car 1 (R to L bottom)
                // x-ray
                if bottom_rightx_car1 - bottom_leftx_car1 > 0
                  max_car1_3x = bottom_rightx_car1;
                  min_car1_3x = bottom_leftx_car1;
                else
                  max_car1_3x = bottom_leftx_car1;
                  min_car1_3x = bottom_rightx_car1;
                end
                // y-ray
                if bottom_righty_car1 - bottom_lefty_car1 > 0
                  max_car1_3y = bottom_righty_car1;
                  min_car1_3y = bottom_lefty_car1;
                else
                  max_car1_3y = bottom_lefty_car1;
                  min_car1_3y = bottom_righty_car1;
                end
                // if there is a collision between diag line 1 of current vehicle and boundary line 3 of car 1
                // first step: Rapid rejection test
                if ( max_diag_1x >= min_car1_3x )&&( max_car1_3x >= min_diag_1x )&&( max_diag_1y >= min_car1_3y )&&( max_car1_3y >= min_diag_1y)
                  Q P1Q1_x = top_rightx - bottom_rightx_car1;
                  Q P1Q1_y = top_righty - bottom_righty_car1;
                  Q Q2Q1_x = bottom_leftx_car1 - bottom_rightx_car1;
                  Q Q2Q1_y = bottom_lefty_car1 - bottom_righty_car1;
                  Q P2Q1_x = bottom_leftx - bottom_rightx_car1;
                  Q P2Q1_y = bottom_lefty - bottom_righty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of current vehicle and boundary line 3 of car 1
                // first step: Rapid rejection test
                if ( max_diag_2x >= min_car1_3x )&&( max_car1_3x >= min_diag_2x )&&( max_diag_2y >= min_car1_3y )&&( max_car1_3y >= min_diag_2y)
                  Q P1Q1_x = top_leftx - bottom_rightx_car1;
                  Q P1Q1_y = top_lefty - bottom_righty_car1;
                  Q Q2Q1_x = bottom_leftx_car1 - bottom_rightx_car1;
                  Q Q2Q1_y = bottom_lefty_car1 - bottom_righty_car1;
                  Q P2Q1_x = bottom_rightx - bottom_rightx_car1;
                  Q P2Q1_y = bottom_righty - bottom_righty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // Boundary line 4 of car 1 (top to bottom L)
                // x-ray
                if top_leftx_car1 - bottom_leftx_car1 > 0
                  max_car1_4x = top_leftx_car1;
                  min_car1_4x = bottom_leftx_car1;
                else
                  max_car1_4x = bottom_leftx_car1;
                  min_car1_4x = top_leftx_car1;
                end
                // y-ray
                if top_lefty_car1 - bottom_lefty_car1 > 0
                  max_car1_4y = top_lefty_car1;
                  min_car1_4y = bottom_lefty_car1;
                else
                  max_car1_4y = bottom_lefty_car1;
                  min_car1_4y = top_lefty_car1;
                end
                // if there is a collision between diag line 1 of current vehicle and boundary line 4 of car 1
                // first step: Rapid rejection test
                if ( max_diag_1x >= min_car1_4x )&&( max_car1_4x >= min_diag_1x )&&( max_diag_1y >= min_car1_4y )&&( max_car1_4y >= min_diag_1y)
                  Q P1Q1_x = top_rightx - top_leftx_car1;
                  Q P1Q1_y = top_righty - top_lefty_car1;
                  Q Q2Q1_x = bottom_leftx_car1 - top_leftx_car1;
                  Q Q2Q1_y = bottom_lefty_car1 - top_lefty_car1;
                  Q P2Q1_x = bottom_leftx - top_leftx_car1;
                  Q P2Q1_y = bottom_lefty - top_lefty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of current vehicle and boundary line 4 of car 1
                // first step: Rapid rejection test
                if ( max_diag_2x >= min_car1_4x )&&( max_car1_4x >= min_diag_2x )&&( max_diag_2y >= min_car1_4y )&&( max_car1_4y >= min_diag_2y)
                  Q P1Q1_x = top_leftx - top_leftx_car1;
                  Q P1Q1_y = top_lefty - top_lefty_car1;
                  Q Q2Q1_x = bottom_leftx_car1 - top_leftx_car1;
                  Q Q2Q1_y = bottom_leftx_car1 - top_lefty_car1;
                  Q P2Q1_x = bottom_rightx - top_leftx_car1;
                  Q P2Q1_y = bottom_righty - top_lefty_car1;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // first diag line of car1(Top R to bottom L)
                // x-ray
                if top_rightx_car1 - bottom_leftx_car1 > 0
                  max_diag_car1_1x = top_rightx_car1;
                  min_diag_car1_1x = bottom_leftx_car1;
                else
                  max_diag_car1_1x = bottom_leftx_car1;
                  min_diag_car1_1x = top_rightx_car1;
                end
                // y-ray
                if top_righty_car1 - bottom_lefty_car1 > 0
                  max_diag_car1_1y = top_righty_car1;
                  min_diag_car1_1y = bottom_lefty_car1;
                else
                  max_diag_car1_1y = bottom_lefty_car1;
                  min_diag_car1_1y = top_righty_car1;
                end
                // second diag line of car1(Top L to bottom R)
                // x-ray
                if top_leftx_car1 - bottom_rightx_car1 > 0
                  max_diag_car1_2x = top_leftx_car1;
                  min_diag_car1_2x = bottom_rightx_car1;
                else
                  max_diag_car1_2x = bottom_rightx_car1;
                  min_diag_car1_2x = top_leftx_car1;
                end
                // y-ray
                if top_lefty_car1 - bottom_righty_car1 > 0
                  max_diag_car1_2y = top_lefty_car1;
                  min_diag_car1_2y = bottom_righty_car1;
                else
                  max_diag_car1_2y = bottom_righty_car1;
                  min_diag_car1_2y = top_lefty_car1;
                end

                // Boundary line 1 of current vehicle(top to bottom R)
                // x-ray
                if top_rightx - bottom_rightx> 0
                  max_1x = top_rightx;
                  min_1x = bottom_rightx;
                else
                  max_1x = bottom_rightx;
                  min_1x = top_rightx;
                end
                // y-ray
                if top_righty - bottom_righty > 0
                  max_1y = top_righty;
                  min_1y = bottom_righty;
                else
                  max_1y = bottom_righty;
                  min_1y = top_righty;
                end
                // if there is a collision between diag line 1 of car1 and boundary line 1 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_1x >= min_1x )&&( max_1x >= min_diag_car1_1x )&&( max_diag_car1_1y >= min_1y )&&( max_1y >= min_diag_car1_1y)
                  Q P1Q1_x = top_rightx_car1 - top_rightx;
                  Q P1Q1_y = top_righty_car1 - top_righty;
                  Q Q2Q1_x = bottom_rightx - top_rightx;
                  Q Q2Q1_y = bottom_righty - top_righty;
                  Q P2Q1_x = bottom_leftx_car1 - top_rightx;
                  Q P2Q1_y = bottom_lefty_car1 - top_righty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of car1 and boundary line 1 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_2x >= min_1x )&&( max_1x >= min_diag_car1_2x )&&( max_diag_car1_2y >= min_1y )&&( max_1y >= min_diag_car1_2y)
                  Q P1Q1_x = top_leftx_car1 - top_rightx;
                  Q P1Q1_y = top_lefty_car1 - top_righty;
                  Q Q2Q1_x = bottom_rightx - top_rightx;
                  Q Q2Q1_y = bottom_righty - top_righty;
                  Q P2Q1_x = bottom_rightx_car1 - top_rightx;
                  Q P2Q1_y = bottom_righty_car1 - top_righty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // Boundary line 2 of current vehicle (R to L top)
                // x-ray
                if top_rightx - top_leftx > 0
                  max_2x = top_rightx;
                  min_2x = top_leftx;
                else
                  max_2x = top_leftx;
                  min_2x = top_rightx;
                end
                // y-ray
                if top_righty - top_lefty > 0
                  max_2y = top_righty;
                  min_2y = top_lefty;
                else
                  max_2y = top_lefty;
                  min_2y = top_righty;
                end
                // if there is a collision between diag line 1 of car1 and boundary line 2 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_1x >= min_2x )&&( max_2x >= min_diag_car1_1x )&&( max_diag_car1_1y >= min_2y )&&( max_2y >= min_diag_car1_1y)
                  Q P1Q1_x = top_rightx_car1 - top_rightx;
                  Q P1Q1_y = top_righty_car1 - top_righty;
                  Q Q2Q1_x = top_leftx - top_rightx;
                  Q Q2Q1_y = top_lefty - top_righty;
                  Q P2Q1_x = bottom_leftx_car1 - top_rightx;
                  Q P2Q1_y = bottom_lefty_car1 - top_righty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of car1 and boundary line 3 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_2x >= min_2x )&&( max_2x >= min_diag_car1_2x )&&( max_diag_car1_2y >= min_2y )&&( max_2y >= min_diag_car1_2y)
                  Q P1Q1_x = top_leftx_car1 - top_rightx;
                  Q P1Q1_y = top_lefty_car1 - top_righty;
                  Q Q2Q1_x = top_leftx - top_rightx;
                  Q Q2Q1_y = top_lefty - top_righty;
                  Q P2Q1_x = bottom_rightx_car1 - top_rightx;
                  Q P2Q1_y = bottom_righty_car1 - top_righty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // Boundary line 3 of current vehicle (R to L bottom)
                // x-ray
                if bottom_rightx - bottom_leftx > 0
                  max_3x = bottom_rightx;
                  min_3x = bottom_leftx;
                else
                  max_3x = bottom_leftx;
                  min_3x = bottom_rightx;
                end
                // y-ray
                if bottom_righty - bottom_lefty > 0
                  max_3y = bottom_righty;
                  min_3y = bottom_lefty;
                else
                  max_3y = bottom_lefty;
                  min_3y = bottom_righty;
                end
                // if there is a collision between diag line 1 of car1 and boundary line 3 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_1x >= min_3x )&&( max_3x >= min_diag_car1_1x )&&( max_diag_car1_1y >= min_3y )&&( max_3y >= min_diag_car1_1y)
                  Q P1Q1_x = top_rightx_car1 - bottom_rightx;
                  Q P1Q1_y = top_righty_car1 - bottom_righty;
                  Q Q2Q1_x = bottom_leftx - bottom_rightx;
                  Q Q2Q1_y = bottom_lefty - bottom_righty;
                  Q P2Q1_x = bottom_leftx_car1 - bottom_rightx;
                  Q P2Q1_y = bottom_lefty_car1 - bottom_righty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of car1 and boundary line 3 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_2x >= min_3x )&&( max_3x >= min_diag_car1_2x )&&( max_diag_car1_2y >= min_3y )&&( max_3y >= min_diag_car1_2y)
                  Q P1Q1_x = top_leftx_car1 - bottom_rightx;
                  Q P1Q1_y = top_lefty_car1 - bottom_righty;
                  Q Q2Q1_x = bottom_leftx - bottom_rightx;
                  Q Q2Q1_y = bottom_lefty - bottom_righty;
                  Q P2Q1_x = bottom_rightx_car1 - bottom_rightx;
                  Q P2Q1_y = bottom_righty_car1 - bottom_righty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // Boundary line 4 of current vehicle (top to bottom L)
                // x-ray
                if top_leftx - bottom_leftx > 0
                  max_4x = top_leftx;
                  min_4x = bottom_leftx;
                else
                  max_4x = bottom_leftx;
                  min_4x = top_leftx;
                end
                // y-ray
                if top_lefty - bottom_lefty > 0
                  max_4y = top_lefty;
                  min_4y = bottom_lefty;
                else
                  max_4y = bottom_lefty;
                  min_4y = top_lefty;
                end
                // if there is a collision between diag line 1 of car1 and boundary line 4 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_1x >= min_4x )&&( max_4x >= min_diag_car1_1x )&&( max_diag_car1_1y >= min_4y )&&( max_4y >= min_diag_car1_1y)
                  Q P1Q1_x = top_rightx_car1 - top_leftx;
                  Q P1Q1_y = top_righty_car1 - top_lefty;
                  Q Q2Q1_x = bottom_leftx - top_leftx;
                  Q Q2Q1_y = bottom_lefty - top_lefty;
                  Q P2Q1_x = bottom_leftx_car1 - top_leftx;
                  Q P2Q1_y = bottom_lefty_car1 - top_lefty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
                // if there is a collision between diag line 2 of car1 and boundary line 4 of current car
                // first step: Rapid rejection test
                if ( max_diag_car1_2x >= min_4x )&&( max_4x >= min_diag_car1_2x )&&( max_diag_car1_2y >= min_4y )&&( max_4y >= min_diag_car1_2y)
                  Q P1Q1_x = top_leftx_car1 - top_leftx;
                  Q P1Q1_y = top_lefty_car1 - top_lefty;
                  Q Q2Q1_x = bottom_leftx - top_leftx;
                  Q Q2Q1_y = bottom_lefty - top_lefty;
                  Q P2Q1_x = bottom_rightx_car1 - top_leftx;
                  Q P2Q1_y = bottom_righty_car1 - top_lefty;
                  Q Prod_P1Q1Q2Q1 = (P1Q1_x * Q2Q1_y) - (Q2Q1_x * P1Q1_y);
                  Q Prod_Q2Q1P2Q1 = (Q2Q1_x * P2Q1_y) - (P2Q1_x * Q2Q1_y);
                  //second step: Stradd test
                  if (Prod_P1Q1Q2Q1 * Prod_Q2Q1P2Q1 >= 0) && (firstcollision == 0)
                    firstcollision = 1;
                    iscollision = 1;
                    collsion_id = car1_id;
                    collison_point_x = trajectory_x(1,i);
                    collison_point_y = trajectory_y(1,i);
                    collison_point_x_car1 = trajectory_x_car1(1,j);
                    collison_point_y_car1 = trajectory_y_car1(1,j);
                  end
                end
              end
            end
          end
          //here to figure the front vehicle
          if iscollision == 1
            if (collison_point_x == trajectory_x(1,1))&&(collison_point_y == trajectory_y(1,1))
              //follow
              proritytocurrent = -3;
            elseif (collison_point_x_car1 == trajectory_x_car1(1,1))&&(collison_point_y_car1 == trajectory_y_car1(1,1))
              //front
              proritytocurrent =  3;
            else
                Q currx = nextintersection_x - trajectory_x(1,1);
                Q curry = nextintersection_y - trajectory_y(1,1);
                Q car1_x = car1_nextintersection_x - trajectory_x_car1(1,1);
                Q car1_y = car1_nextintersection_x - trajectory_y_car1(1,1);
                Q cos_angle = currx * car1_x + curry * car1_y;
                Q sqrt_mode1 =  currx * currx + curry * curry;
                Q mode1 = sqrt(sqrt_mode1);
                Q sqrt_mode2 =  car1_x * car1_x + car1_y * car1_y;
                Q mode2 = sqrt(sqrt_mode2);
                cos_angle = cos_angle/(mode1 * mode2);
                Q angle_between = acos(cos_angle);
                if angle_between > 0.75 * M_PI
                   proritytocurrent = 2.0;
                else
                    Q product = currx * car1_y - car1_x * curry;
                    if product > 0
                      proritytocurrent = 1;
                    elseif product == 0
                      proritytocurrent = 0;
                    else
                      proritytocurrent = -1;
                    end
                end
             end
          end

    }

}
