package de.rwth.pacman.heithoff2.BFS;


// Pacman.WALL    = 0;
// Pacman.BISCUIT = 1;
// Pacman.EMPTY   = 2;
// Pacman.BLOCK   = 3;
// Pacman.PILL    = 4;

component BFSSingle {
    ports
        in Z(-1m: 19m) ghostX[4],
        in Z(0m: 22m) ghostY[4],
        in Z(0 : 1 : 3) ghostDirection[4],
        in B ghostEatable[4],
        in Z^{22,19} map,
        in Z(-1m: 19m) currentX,
        in Z(0m: 22m) currentY,
        in Z(-1m: 19m) oldX,
        in Z(0m: 22m) oldY,
        in B oldSafe,
        in B oldSafeFound,
        in Z oldDirection,
        
        out Z(-1m: 19m) newX,
        out Z(0m: 22m) newY,
        out Z safeFound,
        out Z safe,
        out Z newDirection;
        
    implementation Math {
        newDirection = oldDirection;
        Z indexY = currentY + 1;
        Z indexX = currentX + 1;
        newX = indexX - 1;
        newY = indexY - 1;
        Z currentTile = map(indexY, indexX);
        if (currentTile == 0) || (currentTile == 3) // begin with wall
            safeFound = 1;
            safe = 1;
        elseif (oldSafeFound == 1) || (oldSafe == 0)
            safeFound = oldSafeFound;
            safe = oldSafe;
        else
            Z^{1,4} xOffSet = [0,0,-1,1];
            Z^{1,4} yOffSet = [-1,1,0,0];
            Z xC = indexX;
            Z yC = indexY;
            safe = 1;
            safeFound = 0;
            for i = 1:4
                Z xG = round(ghostX(i) + 1);
                Z yG = round(ghostY(i) + 1);
                if (abs(xG - xC) < 1) && (abs(yG - yC) < 1) && (ghostEatable(i) == 0) && (ghostDirection(i) != oldDirection)
                    safe = 0;
                end
            end
            if (safe == 1)
                Z newPathsFound = 0;
                for i = 0:3
                    indexY = 0;
                    indexX = i;
                    Z xOff = xOffSet(indexY, indexX);
                    Z yOff = yOffSet(indexY, indexX);
                    Q xT = xC + xOff;
                    Q yT = yC + yOff;
                    
                    if (abs(xT - (oldX + 1)) >= 1) || (abs(yT - (oldY + 1)) >= 1)
                        Z nextTile = map(yT, xT);
                        if (nextTile == 0) || (nextTile == 3)
                            newPathsFound = newPathsFound;
                        else
                            newPathsFound = newPathsFound + 1;
                            newX = xT - 1;
                            newY = yT - 1;
                            newDirection = i;
                            if newPathsFound > 1
                                safeFound = 1;
                                newX = currentX;
                                newY = currentY;
                            end
                        end
                    end
                end
            end
        end
    }
}