package de.rwth.pacman.heithoff1.coneSearch.enemySearch;

import de.rwth.pacman.common.Constant;
import de.rwth.pacman.common.ConstantBoolean;
import de.rwth.pacman.common.Greater;
import de.rwth.pacman.common.GreaterEquals;
import de.rwth.pacman.common.Or;
import de.rwth.pacman.common.And;
import de.rwth.pacman.common.Not;
import de.rwth.pacman.common.Switch;
import de.rwth.pacman.common.Abs;
import de.rwth.pacman.common.Difference;

component SearchEnemyRight {
    ports
      in Q(-1m: 19m) currentX,
      in Q(0m: 22m) currentY,
      in Q(-1m: 19m) ghostX,
      in Q(0m: 22m) ghostY,
      in Z ghostDirection,
      in Boolean ghostEatable,
      
      out Z val;

    instance Constant<0> zero;
    instance ConstantBoolean<1> isRight;
    instance Greater ghostIsRightOfPM;
    instance Or<2> correctXIntervalCond;
    instance And<2> correctXIntervalCond1;
    instance Not correctXIntervalCond2;
    instance Switch correctXInterval;
    instance Switch correctYInterval;
    
    connect ghostX -> ghostIsRightOfPM.in1;
    connect currentX -> ghostIsRightOfPM.in2;
    connect ghostIsRightOfPM.out1 -> correctXIntervalCond1.in1[1];
    connect isRight.out1 -> correctXIntervalCond1.in1[2];
    connect correctXIntervalCond1.out1 -> correctXIntervalCond.in1[1];
    connect isRight.out1 -> correctXIntervalCond2.in1;
    connect correctXIntervalCond2.out1 -> correctXIntervalCond.in1[2];
    connect correctXIntervalCond.out1 -> correctXInterval.cond;
    connect zero.out1 -> correctXInterval.in3, correctYInterval.in3;
    connect correctYInterval.out1 -> correctXInterval.in1;

    instance Abs distX, distY;
    instance Difference<2> distXIn, distYIn;
    instance GreaterEquals correctYIntervalCond;
    
    connect currentX -> distXIn.in1[1];
    connect currentY -> distYIn.in1[1];
    connect ghostX   -> distXIn.in1[2];
    connect ghostY   -> distYIn.in1[2];
    connect distXIn.out1 -> distX.in1;
    connect distYIn.out1 -> distY.in1;
    connect distX.out1 -> correctYIntervalCond.in1;
    connect distY.out1 -> correctYIntervalCond.in2;
    connect correctYIntervalCond.out1 -> correctYInterval.cond;

    connect correctXInterval.out1 -> val;

    instance ScoreGhost<2> score;
    connect currentX -> score.currentX;
    connect currentY -> score.currentY;
    connect ghostX -> score.ghostX;
    connect ghostY -> score.ghostY;
    connect ghostDirection -> score.ghostDirection;
    connect ghostEatable -> score.ghostEatable;
    
    connect score.val -> correctYInterval.in1;
}