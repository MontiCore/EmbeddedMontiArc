package de.rwth.pacman.heithoff1.BFS;

import de.rwth.pacman.common.*;
import de.rwth.pacman.heithoff1.BFS.single.SafePosition;

// check whether the surrounding tiles are safe

component EndSafe {
    ports
      in Q(0m: 20m) currentX,
      in Q(1m: 23m) currentY,
      in Q(0m: 20m)^{1,4} ghostX,
      in Q(1m: 23m)^{1,4} ghostY,
      in Z(0 : 1 : 3)^{1,4} ghostDirection,
      in Boolean^{1,4} ghostEatable,
      in Boolean oldSafe,
      in Boolean oldSafeFound,
      in Z oldDirection,
      
      out Boolean safe;

    instance SafePosition safeTop, safeBottom, safeLeft, safeRight;
    instance Constant<-1> minusOne;
    instance Constant<1> one;
    instance Sum<2> yInTop, yInBottom, xInLeft, xInRight;
    instance Constant<0> topDir;
    instance Constant<1> bottomDir;
    instance Constant<2> leftDir;
    instance Constant<3> rightDir;

    connect currentX -> xInLeft.in1[1], xInRight.in1[1];
    connect currentY -> yInTop.in1[1], yInBottom.in1[1];
    connect minusOne.out1 -> yInTop.in1[2], xInLeft.in1[2];
    connect one.out1 -> yInBottom.in1[2], xInRight.in1[2];
    connect currentX -> safeTop.currentX, safeBottom.currentX;
    connect currentY -> safeLeft.currentY, safeRight.currentY;
    connect xInLeft.out1 -> safeLeft.currentX;
    connect xInRight.out1 -> safeRight.currentX;
    connect yInTop.out1 -> safeTop.currentY;
    connect yInBottom.out1 -> safeBottom.currentY;

    connect ghostX -> safeTop.ghostX, safeBottom.ghostX, safeLeft.ghostX, safeRight.ghostX;
    connect ghostY -> safeTop.ghostY, safeBottom.ghostY, safeLeft.ghostY, safeRight.ghostY;
    connect ghostDirection -> safeTop.ghostDirection, safeBottom.ghostDirection, safeLeft.ghostDirection, safeRight.ghostDirection;
    connect ghostEatable -> safeTop.ghostEatable, safeBottom.ghostEatable, safeLeft.ghostEatable, safeRight.ghostEatable;
    connect topDir.out1 -> safeTop.oldDirection;
    connect bottomDir.out1 -> safeBottom.oldDirection;
    connect leftDir.out1 -> safeLeft.oldDirection;
    connect rightDir.out1 -> safeRight.oldDirection;

    instance And<4> isSafe;
    instance And<2> isAndWasSafe;

    connect safeTop.safe -> isSafe.in1[1];
    connect safeBottom.safe -> isSafe.in1[2];
    connect safeLeft.safe -> isSafe.in1[3];
    connect safeRight.safe -> isSafe.in1[4];
    connect isSafe.out1 -> isAndWasSafe.in1[1];
    connect oldSafe -> isAndWasSafe.in1[2];
    connect isAndWasSafe.out1 -> safe;
}