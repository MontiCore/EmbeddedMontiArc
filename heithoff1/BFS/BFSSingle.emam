package de.rwth.pacman.heithoff1.BFS;
import de.rwth.pacman.heithoff1.BFS.single.*;


// Pacman.WALL    = 0;
// Pacman.BISCUIT = 1;
// Pacman.EMPTY   = 2;
// Pacman.BLOCK   = 3;
// Pacman.PILL    = 4;

// check whether the current tile is safe and then calculate the next tile position

component BFSSingle {
    ports
      in Q(0m: 20m)^{1,4} ghostX,
      in Q(1m: 23m)^{1,4} ghostY,
      in Z(0 : 1 : 3)^{1,4} ghostDirection,
      in Boolean^{1,4} ghostEatable,
      in Z^{22,19} map,
      in Q(0m: 20m) currentX,
      in Q(1m: 23m) currentY,
      in Q(0m: 20m) oldX,
      in Q(1m: 23m) oldY,
      in Boolean oldSafe,
      in Boolean oldSafeFound,
      in Z oldDirection,
      
      out Q(0m: 20m) newX,
      out Q(1m: 23m) newY,
      out Boolean safeFound,
      out Boolean safe,
      out Z newDirection;
      
    // sadly this doesnt work, due to some bugs in emam2wasm. Concept is still correct
    // should get fixed, soon
    
     instance ControlFlow control;
     instance ReenterMap reenterMap;
     instance SearchFinished searchFinished;
     instance SafePosition safePosition;
     instance CalcNewPosition calcNewPosition;
    
     connect currentX -> reenterMap.currentX;
     connect currentY -> reenterMap.currentY;
     connect oldX     -> reenterMap.oldX;
     connect oldY     -> reenterMap.oldY;
    
     connect reenterMap.newCurrentX -> searchFinished.currentX, safePosition.currentX, calcNewPosition.currentX, control.currentX;
     connect reenterMap.newCurrentY -> searchFinished.currentY, safePosition.currentY, calcNewPosition.currentY, control.currentY;
     connect map                    -> searchFinished.map, calcNewPosition.map;
     connect oldSafe                -> searchFinished.oldSafe;
     connect oldSafeFound           -> searchFinished.oldSafeFound;
    
     connect ghostX         -> safePosition.ghostX;
     connect ghostY         -> safePosition.ghostY;
     connect ghostDirection -> safePosition.ghostDirection;
     connect ghostEatable   -> safePosition.ghostEatable;
     connect oldDirection      -> safePosition.oldDirection, control.oldDirection;
    
     connect reenterMap.newOldX      -> calcNewPosition.oldX;
     connect reenterMap.newOldY      -> calcNewPosition.oldY;
     connect searchFinished.finished -> calcNewPosition.searchFinished;
     connect safePosition.safe       -> calcNewPosition.positionIsSafe;
    
     connect searchFinished.finished      -> control.searchFinished;
     connect searchFinished.safe          -> control.safeFromSearchFinished;
     connect searchFinished.safeFound     -> control.safeFoundFromSearchFinished;
     connect safePosition.safe            -> control.positionIsSafe;
     connect calcNewPosition.safeFound    -> control.safeFoundFromNewPosition;
     connect calcNewPosition.newX         -> control.newXFromNewPosition;
     connect calcNewPosition.newY         -> control.newYFromNewPosition;
     connect calcNewPosition.newDirection -> control.newDirectionFromNewPosition;
    
     connect control.newX -> newX;
     connect control.newY -> newY;
     connect control.safeFound -> safeFound;
     connect control.safe -> safe;
     connect control.newDirection -> newDirection;
}