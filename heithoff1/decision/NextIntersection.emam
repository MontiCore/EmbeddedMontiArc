package de.rwth.pacman.heithoff1.decision;

import de.rwth.pacman.common.Constant;
import de.rwth.pacman.common.Round;
import de.rwth.pacman.common.Equals;
import de.rwth.pacman.common.And;
import de.rwth.pacman.common.Greater;
import de.rwth.pacman.common.TrashBoolean;

import de.rwth.pacman.heithoff1.common.OutgoingPaths;

// check whether an intersection (3 or more non-blocked paths) is reached

component NextIntersection {
    ports
      in Q(-1m: 19m) pacManX,
      in Q(0m: 22m) pacManY,
      in Z^{22,19} map,
      
      out Boolean interSectionReached;

    // is PM on one full tile
    instance Round pacX, pacY;
    instance Equals eqX, eqY;
    instance And<2> and1;

    connect pacManX -> pacX.in1;
    connect pacManY -> pacY.in1;
    connect pacX.out1 -> eqX.in1;
    connect pacY.out1 -> eqY.in1;
    connect pacManX -> eqX.in2;
    connect pacManY -> eqY.in2;
    connect eqX.out1 -> and1.in1[1];
    connect eqY.out1 -> and1.in1[2];

    // Check for outgoing paths
    instance OutgoingPaths outgoingPaths;
    
    connect map -> outgoingPaths.map;
    connect pacX.out1 -> outgoingPaths.pacManX;
    connect pacY.out1 -> outgoingPaths.pacManY;

    // If the number of outgoing paths is more than two, an intersection is reached
    instance Constant<2> two;
    instance Greater greater;
    
    connect outgoingPaths.outgoingPaths -> greater.in1;
    connect two.out1 -> greater.in2;

    // Logic
    instance And<2> and2;    
    
    connect and1.out1 -> and2.in1[1];
    connect greater.out1 -> and2.in1[2];
    connect and2.out1 -> interSectionReached;

    // Trash
    instance TrashBoolean trash1, trash2, trash3, trash4;

    connect outgoingPaths.isTopFree -> trash1.in1;
    connect outgoingPaths.isBottomFree -> trash2.in1;
    connect outgoingPaths.isLeftFree -> trash3.in1;
    connect outgoingPaths.isRightFree -> trash4.in1;
}