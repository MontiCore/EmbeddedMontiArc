package simulator;

component SteeringAngleCalculator{
    ports in Q(-90°:90°) x[2],
          in Q(-180°:180°) y[2],
          in Q(-90°:90°) gpsX,
          in Q(-180°:180°) gpsY,
          in Q(-180°:180°) orientation,
          in Q(-180°:180°) currentSteeringAngle,
          out Q(-180°:180°) newSteeringAngle;

    instance DistanceToTrajectoryCalculator distanceCalculator;

    connect x[:] -> distanceCalculator.x[:];
    connect y[:] -> distanceCalculator.y[:];
    connect gpsX -> distanceCalculator.gpsX;
    connect gpsY -> distanceCalculator.gpsY;

    implementation Math{
        Q globalOrientation = orientation*(M_PI/180);
        if (globalOrientation > M_PI) {
            globalOrientation -= 2 * M_PI;
        }

        Q orientedDistance = distanceCalculator.distance;
        Q angleTowardsTrajectory = atan(orientedDistance / 2);
        Q orientationOfTrajectory;


        Q v1 = x(2) - x(1);
        Q v2 = y(2) - y(1);
        Q cosineAngle = v2 / sqrt(v1 * v1 + v2 * v2);
        Q angle = acos(cosineAngle);

        if (v1 > 0) {
            orientationOfTrajectory = -angle;
        } else {
            orientationOfTrajectory = angle;
        }
        end
        Q angleTrajectoryAndCarDirection = orientationOfTrajectory - globalOrientation;

        //the resulting angle is the angle needed to steer the car parallel to the trajectory
        // plus the angle towards the trajectory
        Q finalAngle = angleTrajectoryAndCarDirection + angleTowardsTrajectory;





        if (finalAngle > M_PI){
             finalAngle -= 2 * M_PI;
        }elseif (finalAngle < -M_PI){
              finalAngle += 2 * M_PI;
        }
        end
        newSteeringAngle = finalAngle*(180/M_PI);

    }
}