/* generated by template parser.Parser*/

// Generated antlr file

// Parser header
/* generated by template parser.ParserHeader*/
grammar WeatherAntlr;
@parser::header {
package weather._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package weather._parser;
}
options {
superClass=MCParser;
}

@parser::members

{
// Global actions

// Convert functions
  // convert function for TFloatPointUnitNumber
private String convertTFloatPointUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for Significant
private String convertSignificant(Token t)  {
    return t.getText();
}

  // convert function for THexUnitNumber
private String convertTHexUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitNumber
private String convertTUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitInf
private String convertTUnitInf(Token t)  {
    return t.getText();
}

  // convert function for TComplexNumber
private String convertTComplexNumber(Token t)  {
    return t.getText();
}

  // convert function for RealNumber
private String convertRealNumber(Token t)  {
    return t.getText();
}

  // convert function for PosNumber
private String convertPosNumber(Token t)  {
    return t.getText();
}

  // convert function for PosInt
private String convertPosInt(Token t)  {
    return t.getText();
}

  // convert function for UngroupedPosInt
private String convertUngroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for GroupedPosInt
private String convertGroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for PosIntGroup
private String convertPosIntGroup(Token t)  {
    return t.getText();
}

  // convert function for Unit
private String convertUnit(Token t)  {
    return t.getText();
}

  // convert function for ImperialUnit
private String convertImperialUnit(Token t)  {
    return t.getText();
}

  // convert function for OfficallyAcceptedUnit
private String convertOfficallyAcceptedUnit(Token t)  {
    return t.getText();
}

  // convert function for SIUnit
private String convertSIUnit(Token t)  {
    return t.getText();
}

  // convert function for UnitPrefix
private String convertUnitPrefix(Token t)  {
    return t.getText();
}

  // convert function for SiUnitBaseDimension
private String convertSiUnitBaseDimension(Token t)  {
    return t.getText();
}

  // convert function for SiUnitDimensionless
private String convertSiUnitDimensionless(Token t)  {
    return t.getText();
}

  // convert function for Space
private String convertSpace(Token t)  {
    return t.getText();
}

  // convert function for NamePart
private String convertNamePart(Token t)  {
    return t.getText();
}

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for Numb
private String convertNumb(Token t)  {
    return t.getText();
}

}

// Lexer header
/* generated by template parser.LexerMember*/


@lexer::members {

// Add additional Java Code to lexer

private de.monticore.antlr4.MCParser _monticore_parser;
protected de.monticore.antlr4.MCParser getCompiler() {
   return _monticore_parser;
}
public void setMCParser(de.monticore.antlr4.MCParser in) {
  this._monticore_parser = in;
}
}


// Global actions

// Parser rules 
  
 // Start of 'ASTClassProd Number'


number_eof returns [si._ast.ASTNumber ret = null] :
  tmp = number {$ret = $tmp.ret;} EOF ;


  number returns [si._ast.ASTNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=floatPointUnitNumber{_aNode.setFloatPointUnitNumber(_localctx.tmp0.ret);}  
  
  |
   tmp1=hexUnitNumber{_aNode.setHexUnitNumber(_localctx.tmp1.ret);}  
  
  |
   tmp2=complexNumber{_aNode.setComplexNumber(_localctx.tmp2.ret);}  
  
  |
   tmp3=unitNumber{_aNode.setUnitNumber(_localctx.tmp3.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd FloatPointUnitNumber'


floatPointUnitNumber_eof returns [si._ast.ASTFloatPointUnitNumber ret = null] :
  tmp = floatPointUnitNumber {$ret = $tmp.ret;} EOF ;


  floatPointUnitNumber returns [si._ast.ASTFloatPointUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTFloatPointUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTFloatPointUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TFloatPointUnitNumber{_aNode.setTFloatPointUnitNumber(convertTFloatPointUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd HexUnitNumber'


hexUnitNumber_eof returns [si._ast.ASTHexUnitNumber ret = null] :
  tmp = hexUnitNumber {$ret = $tmp.ret;} EOF ;


  hexUnitNumber returns [si._ast.ASTHexUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTHexUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTHexUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=THexUnitNumber{_aNode.setTHexUnitNumber(convertTHexUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd UnitNumber'


unitNumber_eof returns [si._ast.ASTUnitNumber ret = null] :
  tmp = unitNumber {$ret = $tmp.ret;} EOF ;


  unitNumber returns [si._ast.ASTUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TUnitNumber{_aNode.setTUnitNumber(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexNumber'


complexNumber_eof returns [si._ast.ASTComplexNumber ret = null] :
  tmp = complexNumber {$ret = $tmp.ret;} EOF ;


  complexNumber returns [si._ast.ASTComplexNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTComplexNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTComplexNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TComplexNumber{_aNode.setTComplexNumber(convertTComplexNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Temperature'


temperature_eof returns [weather._ast.ASTTemperature ret = null] :
  tmp = temperature {$ret = $tmp.ret;} EOF ;


  temperature returns [weather._ast.ASTTemperature ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTTemperature _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTTemperature();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal temperature'
(TEMPERATURE)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherTemperature(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Humidity'


humidity_eof returns [weather._ast.ASTHumidity ret = null] :
  tmp = humidity {$ret = $tmp.ret;} EOF ;


  humidity returns [weather._ast.ASTHumidity ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTHumidity _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTHumidity();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal humidity'
(HUMIDITY)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherHumidity(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Pressure'


pressure_eof returns [weather._ast.ASTPressure ret = null] :
  tmp = pressure {$ret = $tmp.ret;} EOF ;


  pressure returns [weather._ast.ASTPressure ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPressure _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPressure();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal pressure'
(PRESSURE)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherPressure(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Windstrength'


windstrength_eof returns [weather._ast.ASTWindstrength ret = null] :
  tmp = windstrength {$ret = $tmp.ret;} EOF ;


  windstrength returns [weather._ast.ASTWindstrength ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWindstrength _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWindstrength();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal windstrength'
(WINDSTRENGTH)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherWindstrength(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Winddirection'


winddirection_eof returns [weather._ast.ASTWinddirection ret = null] :
  tmp = winddirection {$ret = $tmp.ret;} EOF ;


  winddirection returns [weather._ast.ASTWinddirection ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWinddirection _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWinddirection();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal winddirection'
(WINDDIRECTION)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherWinddirection(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Precipitationtype'


precipitationtype_eof returns [weather._ast.ASTPrecipitationtype ret = null] :
  tmp = precipitationtype {$ret = $tmp.ret;} EOF ;


  precipitationtype returns [weather._ast.ASTPrecipitationtype ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPrecipitationtype _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPrecipitationtype();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal precipitation_type'
('precipitation_type')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal none'
(NONE)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal drizzle'
(DRIZZLE)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal rain'
(RAIN)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal freezing drizzle'
('freezing drizzle')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal freezing rain'
('freezing rain')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow rain'
('snow rain')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snain'
(SNAIN)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow'
(SNOW)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow grains'
('snow grains')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal ice pellets'
('ice pellets')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal sleet'
(SLEET)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal hail'
(HAIL)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow pellets'
('snow pellets')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal graupel'
(GRAUPEL)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal ice crystals'
('ice crystals')// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Precipitationamount'


precipitationamount_eof returns [weather._ast.ASTPrecipitationamount ret = null] :
  tmp = precipitationamount {$ret = $tmp.ret;} EOF ;


  precipitationamount returns [weather._ast.ASTPrecipitationamount ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPrecipitationamount _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPrecipitationamount();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal precipitation_amount'
('precipitation_amount')// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherPrecipitationamount(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Clouding'


clouding_eof returns [weather._ast.ASTClouding ret = null] :
  tmp = clouding {$ret = $tmp.ret;} EOF ;


  clouding returns [weather._ast.ASTClouding ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTClouding _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTClouding();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal clouding'
(CLOUDING)// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal cirrostratus'
(CIRROSTRATUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal altostratus'
(ALTOSTRATUS)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal stratus'
(STRATUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal nimbostratus'
(NIMBOSTRATUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal noctilucent'
(NOCTILUCENT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal polar stratospheric'
('polar stratospheric')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cirrus'
(CIRRUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cirrocumulus'
(CIRROCUMULUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal altocumulus'
(ALTOCUMULUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal stratocumulus'
(STRATOCUMULUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulus humilis'
('cumulus humilis')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulus mediocris'
('cumulus mediocris')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulus congestus'
('cumulus congestus')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulonimbus'
(CUMULONIMBUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal none'
(NONE)// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Sight'


sight_eof returns [weather._ast.ASTSight ret = null] :
  tmp = sight {$ret = $tmp.ret;} EOF ;


  sight returns [weather._ast.ASTSight ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTSight _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTSight();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sight'
(SIGHT)// End of 'ASTTerminal'

  (
  
   tmp0=unitNumber{_aNode.setWeatherSight(_localctx.tmp0.ret);}  
  
  |
  
 // Start of 'ASTTerminal unlimited'
(UNLIMITED)// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd WeatherPhenomena'


weatherPhenomena_eof returns [weather._ast.ASTWeatherPhenomena ret = null] :
  tmp = weatherPhenomena {$ret = $tmp.ret;} EOF ;


  weatherPhenomena returns [weather._ast.ASTWeatherPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWeatherPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWeatherPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal weather_phenomena'
('weather_phenomena')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal fog'
(FOG)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal rope tornado'
('rope tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cone tornado'
('cone tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal wedge tornado'
('wedge tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal multi-vortex tornado'
('multi-vortex tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal landspout'
(LANDSPOUT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal waterspout'
(WATERSPOUT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal gustnado'
(GUSTNADO)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal dust devil'
('dust devil')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal steam devil'
('steam devil')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal thunderstorm'
(THUNDERSTORM)// End of 'ASTTerminal'

  
)
  (
  
  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

  (
  
  (tmp0=Numb{_aNode.setPosX(convertNumb($tmp0));}

  ) 
  
  
)
  (
  
  (tmp1=Numb{_aNode.setPosY(convertNumb($tmp1));}

  ) 
  
  
)
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)?
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd OpticalPhenomena'


opticalPhenomena_eof returns [weather._ast.ASTOpticalPhenomena ret = null] :
  tmp = opticalPhenomena {$ret = $tmp.ret;} EOF ;


  opticalPhenomena returns [weather._ast.ASTOpticalPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTOpticalPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTOpticalPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal optical_phenomena'
('optical_phenomena')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal rainbow'
(RAINBOW)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal northern lights'
('northern lights')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal circumzenithal arc'
('circumzenithal arc')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal zodiacal light'
('zodiacal light')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal crepuscular rays'
('crepuscular rays')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal mirage'
(MIRAGE)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal fog bow'
('fog bow')// End of 'ASTTerminal'

  
)
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ArtificialPhenomena'


artificialPhenomena_eof returns [weather._ast.ASTArtificialPhenomena ret = null] :
  tmp = artificialPhenomena {$ret = $tmp.ret;} EOF ;


  artificialPhenomena returns [weather._ast.ASTArtificialPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTArtificialPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTArtificialPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal artificial_phenomena'
('artificial_phenomena')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal contrails'
(CONTRAILS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal smog'
(SMOG)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal rocket exhaust trails'
('rocket exhaust trails')// End of 'ASTTerminal'

  
)
  
)
  ;
  // End of 'ASTClassProd'


// Extra Rules for Interfaces
 
// Lexer symbols
  CONTRAILS : 'contrails';
  SNAIN : 'snain';
  ALTOSTRATUS : 'altostratus';
  SMOG : 'smog';
  LANDSPOUT : 'landspout';
  NONE : 'none';
  NIMBOSTRATUS : 'nimbostratus';
  CUMULONIMBUS : 'cumulonimbus';
  STRATUS : 'stratus';
  STRATOCUMULUS : 'stratocumulus';
  MIRAGE : 'mirage';
  TEMPERATURE : 'temperature';
  SIGHT : 'sight';
  HUMIDITY : 'humidity';
  WATERSPOUT : 'waterspout';
  SLEET : 'sleet';
  NOCTILUCENT : 'noctilucent';
  GRAUPEL : 'graupel';
  RAIN : 'rain';
  ALTOCUMULUS : 'altocumulus';
  UNLIMITED : 'unlimited';
  CIRRUS : 'cirrus';
  GUSTNADO : 'gustnado';
  LPAREN : '(';
  RPAREN : ')';
  PRESSURE : 'pressure';
  DRIZZLE : 'drizzle';
  HAIL : 'hail';
  WINDDIRECTION : 'winddirection';
  CIRROCUMULUS : 'cirrocumulus';
  RAINBOW : 'rainbow';
  CLOUDING : 'clouding';
  SNOW : 'snow';
  WINDSTRENGTH : 'windstrength';
  CIRROSTRATUS : 'cirrostratus';
  THUNDERSTORM : 'thunderstorm';
  FOG : 'fog';
 
// Lexer rules 
  
 // Start of 'ASTLexProd Numb'
Numb 
  
:
  
  (
  
  '0' 
  |
  (
  
  '1'..'9'  
  )
+
  (
  
  '0'..'9'  
  )
*
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TFloatPointUnitNumber'
TFloatPointUnitNumber 
  
:
  
   Significant 
  (
  
  'e' 
  |
  'E' 
  )

  (
  
  '-' 
  |
  '+' 
  )

  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Significant'
fragment Significant 
  
:
  
  (
  
  '0'..'9'  
  )

  '.' 
  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd THexUnitNumber'
THexUnitNumber 
  
:
  
  '0x' 
  (
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitNumber'
TUnitNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
   Unit 
  (
  
  (
   Space 
  )
*
  (
  
  '*' 
  |
  '/' 
  )

   Unit 
  )
*
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitInf'
TUnitInf 
  
:
  
  (
  
  '-' 
  |
  '+' 
  )
?
  'o' 
  'o' 
  (
  
  (
   Space 
  )
+
   Unit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TComplexNumber'
TComplexNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
  (
  
  '+' 
  |
  '-' 
  )

  (
   Space 
  )
*
   PosNumber 
  'i' 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd RealNumber'
fragment RealNumber 
  
:
  
  (
  '-' 
  )
?
   PosNumber 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosNumber'
fragment PosNumber 
  
:
  
  (
  
   PosInt 
  (
   Space 
  )
*
  '/' 
  (
   Space 
  )
*
   PosInt 
  )

  |
  (
  
   PosInt 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  )

  |
  '0' 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosInt'
fragment PosInt 
  
:
  
   UngroupedPosInt 
  |
   GroupedPosInt 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UngroupedPosInt'
fragment UngroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd GroupedPosInt'
fragment GroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
?
  (
  
  '0'..'9'  
  )
?
  (
   PosIntGroup 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosIntGroup'
fragment PosIntGroup 
  
:
  
  '\'' 
  '0'..'9'  
  '0'..'9'  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Unit'
fragment Unit 
  
:
  
   SIUnit 
  |
   ImperialUnit 
  |
   OfficallyAcceptedUnit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ImperialUnit'
fragment ImperialUnit 
  
:
  
  'th' 
  |
  'in' 
  |
  'ft' 
  |
  'yd' 
  |
  'ch' 
  |
  'fur' 
  |
  'ml' 
  |
  'lea' 
  |
  'ftm' 
  |
  'fl oz' 
  |
  'gi' 
  |
  'pt' 
  |
  'qt' 
  |
  'gal' 
  |
  'gr' 
  |
  'dr' 
  |
  'oz' 
  |
  'lb' 
  |
  'st' 
  |
  'qr' 
  |
  'qtr' 
  |
  'cwt' 
  |
  'slug' 
  |
  'Â°F' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OfficallyAcceptedUnit'
fragment OfficallyAcceptedUnit 
  
:
  
  'min' 
  |
  'h' 
  |
  'd' 
  |
  'ha' 
  |
  'l' 
  |
  'L' 
  |
  't' 
  |
  'au' 
  |
  'AU' 
  |
  'Np' 
  |
  'B' 
  |
  'dB' 
  |
  'eV' 
  |
  'u' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SIUnit'
fragment SIUnit 
  
:
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  (
  
  (
  
  '/' 
  |
  '*' 
  )

  (
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  )

  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  )
*
  |
   SiUnitDimensionless 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnitPrefix'
fragment UnitPrefix 
  
:
  
  'Y' 
  |
  'Z' 
  |
  'E' 
  |
  'P' 
  |
  'T' 
  |
  'G' 
  |
  'M' 
  |
  'K' 
  |
  'k' 
  |
  'H' 
  |
  'da' 
  |
  'd' 
  |
  'c' 
  |
  'm' 
  |
  'n' 
  |
  'p' 
  |
  'f' 
  |
  'a' 
  |
  'z' 
  |
  'y' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitBaseDimension'
fragment SiUnitBaseDimension 
  
:
  
  'm' 
  |
  'g' 
  |
  's' 
  |
  'A' 
  |
  'K' 
  |
  'mol' 
  |
  'cd' 
  |
  'Hz' 
  |
  'N' 
  |
  'Pa' 
  |
  'J' 
  |
  'W' 
  |
  'C' 
  |
  'V' 
  |
  'F' 
  |
  'Î©' 
  |
  'S' 
  |
  'Wb' 
  |
  'T' 
  |
  'H' 
  |
  'Â°C' 
  |
  'lm' 
  |
  'lx' 
  |
  'Bq' 
  |
  'Gy' 
  |
  'Sv' 
  |
  'kat' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitDimensionless'
fragment SiUnitDimensionless 
  
:
  
  'rad' 
  |
  'sr' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Space'
fragment Space 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NamePart'
fragment NamePart 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  (
   NamePart 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  (
  
  '\n' 
  |
  '\r' 
  (
  
  '\n' 
  )
?
  )
?
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'


