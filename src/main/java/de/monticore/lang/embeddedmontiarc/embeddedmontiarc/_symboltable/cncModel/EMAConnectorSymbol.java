/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang.embeddedmontiarc.embeddedmontiarc._symboltable.cncModel;

import de.monticore.lang.embeddedmontiarc.embeddedmontiarc._symboltable.instanceStructure.EMAComponentInstanceSymbol;
import de.monticore.lang.embeddedmontiarc.embeddedmontiarc._symboltable.instanceStructure.EMAComponentInstantiationSymbol;
import de.monticore.lang.embeddedmontiarc.embeddedmontiarc._symboltable.instanceStructure.EMAConnectorInstanceKind;
import de.monticore.lang.embeddedmontiarc.embeddedmontiarc.types.TypesPrinter;
import de.monticore.lang.embeddedmontiarc.helper.SymbolPrinter;
import de.monticore.symboltable.CommonSymbol;
import de.se_rwth.commons.Joiners;
import de.se_rwth.commons.Splitters;
import de.se_rwth.commons.logging.Log;

import java.util.*;

/**
 * Symboltable entry for connectors.
 *
 * @author Arne Haber, Michael von Wenckstern
 */
public class EMAConnectorSymbol extends CommonSymbol implements EMAElementSymbol {

    /* generated by template symboltable.symbols.KindConstantDeclaration */

    public static final EMAConnectorKind KIND = EMAConnectorKind.INSTANCE;

    /**
     * Source of this connector.
     */
    protected String source;

    /**
     * Target of this connector.
     */
    protected String target;

    protected boolean isConstant = false;

    /**
     * is null if not a constantConnector
     */
    protected EMAPortSymbol constantEmaPortSymbol = null;

    /**
     * use {@link #builder()}
     */
    protected EMAConnectorSymbol(String name) {
        super(TypesPrinter.fixTargetName(name), KIND);
    }

    protected EMAConnectorSymbol(String name, EMAConnectorInstanceKind kind) {
        super(TypesPrinter.fixTargetName(name), kind);
    }

    public static EMAConnectorBuilder builder() {
        return new EMAConnectorBuilder();
    }

    public void setIsConstantConnector(boolean isConstantConnector) {
        this.isConstant = isConstantConnector;
    }

    public boolean isConstant() {
        return isConstant;
    }

    public void setConstantEMAPortSymbol(EMAPortSymbol portSymbol) {
        this.constantEmaPortSymbol = portSymbol;
        setIsConstantConnector(portSymbol != null && portSymbol.isConstant());
    }

    /**
     * NOTE: This method is not supported for ConstantConnectors
     *
     * @return the source
     */
    public String getSource() {

        return source;
    }

    /**
     * @param source the source to set
     */
    public void setSource(String source) {
        this.source = source;
    }

    protected EMAPortSymbol getPort(String name) {
        if (this.getEnclosingScope() == null) {
            Log.warn("Connector does not belong to a component, cannot resolve port");
            return null;
        }
        if (!this.getEnclosingScope().getSpanningSymbol().isPresent()) {
            Log.warn(
                    "Connector is not embedded in component symbol, cannot resolve port");
            return null;
        }

        // (1) try to load Component.Port
        String fullSource = Joiners.DOT.join(this.getPackageName(),
                this.getEnclosingScope().getSpanningSymbol().get().getName(), name);
        Optional<EMAPortSymbol> port = this.getEnclosingScope().<EMAPortSymbol>resolve(fullSource,
                EMAPortSymbol.KIND);
        if (port.isPresent()) {
            return port.get();
        }


        EMAComponentSymbol cmp = (EMAComponentSymbol) this.getEnclosingScope().getSpanningSymbol().get();
        // (2) try to load Component.instance.Port
        Iterator<String> parts = Splitters.DOT.split(name).iterator();
        Log.debug("" + name, "NAME:");
        if (!parts.hasNext()) {
            Log.warn("name of connector's source/target is empty, cannot resolve port");
            return null;
        }
        String instance = parts.next();
        Log.debug("" + instance, "instance");
        if (!parts.hasNext()) {
            Log.warn(
                    "name of connector's source/target does has two parts: instance.port, cannot resolve port");
            return null;
        }
        String instancePort = parts.next();
        Log.debug("" + instancePort, "instancePort");
        Optional<EMAComponentInstantiationSymbol> inst = cmp.getSpannedScope()
                .<EMAComponentInstantiationSymbol>resolve(instance, EMAComponentInstantiationSymbol.KIND);
        if (!inst.isPresent()) {
            Log.warn(String.format("Could not find instance %s in component %s, cannot resolve port",
                    instance, cmp.getFullName()));
            return null;
        }
        port = inst.get().getComponentType().getReferencedSymbol().getSpannedScope()
                .resolve(instancePort, EMAPortSymbol.KIND);
        if (port.isPresent()) {
            return port.get();
        }
        Log.debug("No case match for" + name, "cannot resolve port");
        return null;
    }

    /**
     * does not return Optional, since every connector has a port if the model is well-formed
     */
    public EMAPortSymbol getSourcePort() {
        if (isConstant())
            return constantEmaPortSymbol;
        return getPort(this.getSource());
    }

    /**
     * does not return Optional, since every connector has a port if the model is well-formed
     */
    public EMAPortSymbol getTargetPort() {
        return getPort(this.getTarget());
    }

    /**
     * returns the component which defines the connector this is independent from the component to
     * which the source and target ports belong to
     *
     * @return is is the component symbol
     */
    public EMAComponentSymbol getComponent() {
        return (EMAComponentSymbol) this.getEnclosingScope().getSpanningSymbol().get();
    }


    /**
     * @return the target
     */
    public String getTarget() {
        return target;
    }

    /**
     * @param target the target to set
     */
    public void setTarget(String target) {

        this.target = TypesPrinter.fixTargetName(target);
    }

    @Override
    public String toString() {
        return SymbolPrinter.printConnector(this);
    }

    @Override
    public String getName() {
        return getTarget();
    }

    public static EMAPortSymbol connectorSourcePort(EMAComponentInstanceSymbol inst,
                                                    EMAConnectorSymbol c) {
        Iterator<String> parts = Splitters.DOT.split(c.getSource()).iterator();
        Optional<String> instance = Optional.empty();
        Optional<String> instancePort;
        Optional<EMAPortSymbol> port;
        if (parts.hasNext()) {
            instance = Optional.of(parts.next());
        }
        if (parts.hasNext()) {
            instancePort = Optional.of(parts.next());
            instance = Optional.of(TypesPrinter.FirstLowerCase(instance.get()));

            EMAComponentInstanceSymbol inst2 = inst.getSubComponent(instance.get()).get();
            port = inst2.getSpannedScope().<EMAPortSymbol>resolve(instancePort.get(), EMAPortSymbol.KIND);
        } else {
            instancePort = instance;

            port = inst.getSpannedScope().<EMAPortSymbol>resolve(instancePort.get(), EMAPortSymbol.KIND);
        }

        if (port.isPresent()) {
            return port.get();
        }

        Log.debug("False Source: " + c.getSource() + " in: " + c.getEnclosingScope().getName().get(),
                "EMAConnectorSymbol");
        Log.error("0xAC012 No source has been set for the connector symbol");
        return null;
    }



}
