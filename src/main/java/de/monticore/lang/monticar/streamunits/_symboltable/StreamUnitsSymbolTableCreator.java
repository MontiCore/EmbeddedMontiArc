/* (c) https://github.com/MontiCore/monticore */
/* generated from model null*/
/* generated by template symboltable.SymbolTableCreator*/


package de.monticore.lang.monticar.streamunits._symboltable;

import de.monticore.lang.monticar.streamunits._ast.*;
import de.monticore.lang.monticar.streamunits._parser.StreamUnitsParser;
import de.monticore.literals.literals._ast.ASTDoubleLiteral;
import de.monticore.literals.literals._ast.ASTSignedLiteral;
import de.monticore.symboltable.ArtifactScope;
import de.monticore.symboltable.MutableScope;
import de.monticore.symboltable.ResolvingConfiguration;
import de.se_rwth.commons.Names;
import de.se_rwth.commons.logging.Log;
import nu.pattern.OpenCV;
import org.apache.commons.io.FilenameUtils;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class StreamUnitsSymbolTableCreator extends StreamUnitsSymbolTableCreatorTOP {

    private static int id = 0;

    public StreamUnitsSymbolTableCreator(
            final ResolvingConfiguration resolvingConfig, final MutableScope enclosingScope) {
        super(resolvingConfig, enclosingScope);
    }

    @Override
    public void visit(ASTStreamUnitsCompilationUnit node) {
        Log.debug("Building Symboltable for Stream: " + node.getComponentStreamUnits().getName(),
                StreamUnitsSymbolTableCreator.class.getSimpleName());
        String compilationUnitPackage = Names.getQualifiedName(node.getPackageList());
        ArtifactScope artifactScope = new ArtifactScope(
                Optional.empty(),
                compilationUnitPackage,
                new ArrayList<>());
        putOnStack(artifactScope);
        id++;
    }

    @Override
    public void endVisit(ASTStreamUnitsCompilationUnit node) {
        removeCurrentScope();
    }

    @Override
    public void visit(ASTComponentStreamUnits node) {
        ComponentStreamUnitsSymbol streamSymbol = new ComponentStreamUnitsSymbol(node.getName());
        addToScopeAndLinkWithNode(streamSymbol, node);
    }

    @Override
    public void endVisit(ASTComponentStreamUnits node) {
        removeCurrentScope();
    }

    @Override
    public void visit(ASTNamedStreamUnits node) {
        String qualifiedName;
        if(node.getFieldQualifierList().isEmpty()) {
            qualifiedName = node.getName();
        }else{
            qualifiedName = node.getName() + "." + String.join(".", node.getFieldQualifierList());
        }
        NamedStreamUnitsSymbol streamSymbol = new NamedStreamUnitsSymbol(qualifiedName, id);
        for (ASTStreamInstruction streamInstruction : node.getStream().getStreamInstructionList()) {
            handleStreamInstruction(streamSymbol, streamInstruction);
        }
        addToScopeAndLinkWithNode(streamSymbol, node);
    }

    private void handleStreamInstruction(NamedStreamUnitsSymbol streamSymbol,
                                                           ASTStreamInstruction streamInstruction) {
        if (streamInstruction.getStreamValueOpt().isPresent()) {
            streamSymbol.add(handleStreamValue(streamInstruction.getStreamValueOpt().get()));
        } else if (streamInstruction.getStreamCompareOpt().isPresent()) {
            ASTStreamCompare astStreamCompare = streamInstruction.getStreamCompareOpt().get();
            streamSymbol.add(new StreamCompare(new StreamValuePrecision(astStreamCompare.getLeft()),
                    astStreamCompare.getOperator(), new StreamValuePrecision(astStreamCompare.getRight())));
        } else if (streamInstruction.getStreamArrayValuesOpt().isPresent()) {
            streamSymbol.add(handleStreamArrayValues(streamInstruction, Optional.empty(), Optional.empty()));
        } else if (streamInstruction.getFilePathOpt().isPresent()) {
            handleFilePath(streamSymbol, streamInstruction);
        } else if (streamInstruction.getImagePathOpt().isPresent()) {
            streamSymbol.add(handleImagePath(streamInstruction.getImagePathOpt().get()));
        }
    }

    private void handleStreamInstructionForFilePath(NamedStreamUnitsSymbol streamSymbol,
                                         ASTStreamInstruction streamInstruction,
                                         Optional<ASTDoubleLiteral> elementTolerance,
                                                    Optional<ASTDoubleLiteral> generalTolerance) {
        if (streamInstruction.getStreamValueOpt().isPresent()) {
            streamSymbol.add(handleStreamValue(streamInstruction.getStreamValueOpt().get()));
        } else if (streamInstruction.getStreamCompareOpt().isPresent()) {
            ASTStreamCompare astStreamCompare = streamInstruction.getStreamCompareOpt().get();
            streamSymbol.add(new StreamCompare(new StreamValuePrecision(astStreamCompare.getLeft()),
                    astStreamCompare.getOperator(), new StreamValuePrecision(astStreamCompare.getRight())));
        } else if (streamInstruction.getStreamArrayValuesOpt().isPresent()) {
            streamSymbol.add(handleStreamArrayValues(streamInstruction, elementTolerance, generalTolerance));
        } else if (streamInstruction.getFilePathOpt().isPresent()) {
            handleFilePath(streamSymbol, streamInstruction);
        }
    }

    private void handleFilePath(NamedStreamUnitsSymbol streamSymbol, ASTStreamInstruction streamInstruction) {
        ASTFilePath astFilePath = streamInstruction.getFilePathOpt().get();
        final String dir = System.getProperty("user.dir");
        final String filePath = dir + astFilePath.getStringLiteral().getSource();
        File file = new File(filePath);

        if (file.exists()) {
            try {
                Optional<ASTStreamInstruction> astStreamInstruction =
                        handleFileByExtension(file);
                astStreamInstruction.ifPresent(instruction ->
                        handleStreamInstructionForFilePath(streamSymbol, instruction, astFilePath.getElementToleranceOpt(), astFilePath.getGeneralToleranceOpt()));
            } catch (IOException | NumberFormatException e) {
                if (e instanceof  IOException) {
                    Log.error("Error on reading file:" + filePath);
                } else {
                    e.printStackTrace();
                }
            }
        }
    }

    private Optional<ASTStreamInstruction> handleFileByExtension(File file) throws IOException {
        String extension = FilenameUtils.getExtension(file.getPath());
        if (extension.equals("txt")) {
            Path path = file.toPath();
            List<String> content = Files.readAllLines(path, Charset.defaultCharset());
            return new StreamUnitsParser().parse_StringStreamInstruction((content.get(0)));
        } else if (extension.equals("png")) {
            double[][][] cube = handleFilePNG(file);
            return new StreamUnitsParser().parse_StringStreamInstruction(convertCubeToString(cube));
        }
        Log.error("File Extension not supported");
        return Optional.empty();
    }

    private String convertCubeToString(double[][][] cube) {
        String str = "[";
        for (int k = 0; k < cube.length; k++) {
            str += "[";
            double[][] matrix = cube[k];
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[i].length; j++) {
                    str += " " + matrix[i][j];
                    if (j < matrix[i].length - 1) {
                        str += ",";
                    }
                }
                if (i < matrix.length - 1) {
                    str += ";";
                }
            }
            str += "]";
        }

        str += "]";
        return str;
    }

    private double[][][] handleFilePNG(File file) {
        OpenCV.loadShared();
        Mat img = Imgcodecs.imread(file.getAbsolutePath());
        Log.debug("Original image size:", img.size().toString());

        Log.debug("Start resizing for ", file.getName());
        Size scale = new Size(28, 28);
        Imgproc.resize(img, img, scale);

        int channels = 1;
        int height = img.rows();
        int width = img.width();

        double[] data = new double[channels * height * width];

        for (int j = 0; j < height; j++) {
            for (int k = 0; k < width; k++) {
                double[] intensity = img.get(j, k);
                for (int i = 0; i < channels; i++) {
                    data[i * height * width + j * height + k] = intensity[i];
                }
            }
        }

        return translateToCube(data, new int[]{channels, height, width});
    }

    private double[][][] translateToCube(double[] source, int[] shape) {
        assert(shape.length == 3);
        double[][][] cubeMatrix = new double[shape[0]][shape[1]][shape[2]]; // slices(channels), rows(height), columns(width)
        final int matrixSize = shape[1] * shape[2];
        long[] matrixShape = new long[]{shape[1], shape[2]}; // rows, columns
        int startPos = 0;
        int endPos = matrixSize;

        for (int i = 0; i < shape[0]; i++) {
            double[] matrixSource = Arrays.copyOfRange(source, startPos, endPos);
            cubeMatrix[i] = translateToMat(matrixSource, matrixShape);
            startPos = endPos;
            endPos += matrixSize;
        }
        return cubeMatrix;
    }

    private double[][] translateToMat(double[] source, long[] shape) { // shape {rows, columns}
        assert(shape.length == 2);
        double[][] matrix = new double[(int) shape[1]][(int) shape[0]]; // this matrix should be inverted
        int startPos = 0;
        int endPos = (int) shape[1];
        final int[] columnShape = new int[]{(int) shape[1]};
        for (int i = 0; i < shape[0]; i++) {  // for each column
            double[] colSource = Arrays.copyOfRange(source, startPos, endPos);
            matrix[i] = translateToCol(colSource, columnShape);
            startPos = endPos;
            endPos += shape[1];
        }
        return inverte(matrix);
    }

    private double[][] inverte(double[][] matrix) {
        int oldRows = matrix.length;
        int oldColumns = matrix.length > 0 ? matrix[0].length : 0;
        int newRows = oldRows;
        int newColumns = oldRows;
        double[][] inverted = new double[newRows][newColumns];
        for (int i = 0; i < oldRows; i++) {
            for (int j = 0; j < oldColumns; j++) {
                inverted[j][i] = matrix[i][j];
            }
        }
        return inverted;
    }


    private double[] translateToCol(double[] source, int[] shape) {
        assert shape.length == 1;
        double[] column = new double[shape[0]];
        for (int i = 0; i < source.length; i++) {
            column[i] = source[i];
        }
        return column;
    }

    private IStreamValue handleStreamValue(ASTStreamValue streamValue) {
        IStreamValue result = null;
        if (streamValue.getPrecisionNumberOpt().isPresent()) {
            ASTPrecisionNumber num = streamValue.getPrecisionNumberOpt().get();
            if (num.getPrecisionOpt().isPresent()) {
                result = new StreamValuePrecision(num.getNumberWithUnit(), num.getPrecisionOpt().get().getNumberWithUnit());
            } else {
                result = (new StreamValuePrecision(num.getNumberWithUnit()));
            }
        } else if (streamValue.getNameOpt().isPresent()) {
            result = (new StreamValuePrecision(streamValue.getNameOpt().get()));
        } else if (streamValue.getSignedLiteralOpt().isPresent()) {
            ASTSignedLiteral signedLiteral = streamValue.getSignedLiteralOpt().get();
            result = (new StreamValuePrecision(signedLiteral));
        } else if (streamValue.getDontCareOpt().isPresent()) {
            result = (new StreamValuePrecision("-"));
        } else if (streamValue.getValueAtTickOpt().isPresent()) {
            ASTValueAtTick valueAtTick = streamValue.getValueAtTickOpt().get();
            result = (new StreamValueAtTick(valueAtTick));
        }
        return result;
    }

    private StreamValues handleStreamArrayValues(ASTStreamInstruction streamInstruction,
                                                 Optional<ASTDoubleLiteral> elementTolerance, Optional<ASTDoubleLiteral> generalTolerance) {
        ASTStreamArrayValues streamArrayValues = streamInstruction.getStreamArrayValues();
        StreamValues result = null;
        if (streamArrayValues.getMatrixPairOpt().isPresent()) {
            result = handleMatrixPair(streamArrayValues.getMatrixPairOpt().get());
        } else if (streamArrayValues.getValuePairOpt().isPresent()) {
            result = new StreamValues(handleValuePair(streamArrayValues.getValuePairOpt().get()));
        } else if (streamArrayValues.getCubePairOpt().isPresent()) {
            result = handleCubePair(streamArrayValues.getCubePairOpt().get());
        }

        if (result != null) {
            if (streamArrayValues.getElementToleranceOpt().isPresent()) {
                if (elementTolerance.isPresent()) {
                    result.setElementTolerance(elementTolerance.get().getValue());
                } else {
                    result.setElementTolerance(streamArrayValues.getElementToleranceOpt().get().getValue());
                }
            } else {
                if (elementTolerance.isPresent()) {
                    result.setElementTolerance(elementTolerance.get().getValue());
                }
            }

            if (streamArrayValues.getGeneralToleranceOpt().isPresent()) {
                if (generalTolerance.isPresent()) {
                    result.setGeneralTolerance(generalTolerance.get().getValue());
                } else {
                    result.setGeneralTolerance(streamArrayValues.getGeneralToleranceOpt().get().getValue());
                }
            } else {
                if (generalTolerance.isPresent()) {
                    result.setGeneralTolerance(generalTolerance.get().getValue());
                }
            }
        }


        return result;
    }

    private StreamValues handleCubePair(ASTCubePair astCubePair) {
        StreamValues streamValues = new StreamValues();
        for (int slice = 0; slice < astCubePair.getMatrixPairList().size(); slice++) {
            //TODO: StreamValuesValues???
            streamValues.setStreamValues(handleMatrixPair(astCubePair.getMatrixPairList().get(slice)).streamValues.get(0));
        }
        return streamValues;
    }

    private StreamValues handleMatrixPair(ASTMatrixPair matrixPair) {
        //handle all rows
        StreamValues streamValues = new StreamValues();
        for (int row = 0; row < matrixPair.getValuePairList().size(); ++row) {
            streamValues.add(handleValuePair(matrixPair.getValuePairList().get(row)));
        }
        return streamValues;
    }

    private List<IStreamValue> handleValuePair(ASTValuePair valuePair) {
        List<ASTStreamValue> streamValues = valuePair.getStreamValueList();
        List<IStreamValue> currentList = new ArrayList<>();
        //handle the elements of each row
        for (int i = 0; i < streamValues.size(); ++i) {
            currentList.add(handleStreamValue(streamValues.get(i)));
        }
        return currentList;
    }

    private ImagePath handleImagePath(ASTImagePath imagePath) {
        ImagePath result = new ImagePath();
        result.setImagePath(imagePath.getStringLiteral().getValue());
        return result;
    }
}
