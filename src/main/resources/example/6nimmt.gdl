// 6 nimm!

// Roles
//----
(role red)
(role blue)
(role green)
(role yellow)

(role random)

//Initial State
//----
//Before dealing cards

//all, red, blue, green, yellow, random
(init (control random))

// 4 Stacks
//(stack <stack#> <stack pos>)
(init (stack a 1 0))
(init (stack a 2 0))
(init (stack a 3 0))
(init (stack a 4 0))
(init (stack a 5 0))
(init (stack a 6 0))

(init (stack b 1 0))
(init (stack b 2 0))
(init (stack b 3 0))
(init (stack b 4 0))
(init (stack b 5 0))
(init (stack b 6 0))

(init (stack c 1 0))
(init (stack c 2 0))
(init (stack c 3 0))
(init (stack c 4 0))
(init (stack c 5 0))
(init (stack c 6 0))

(init (stack d 1 0))
(init (stack d 2 0))
(init (stack d 3 0))
(init (stack d 4 0))
(init (stack d 5 0))
(init (stack d 6 0))

//4 Hands, 10 cards each
// (hand <role> <pos> <card>)
(init (sees red (hand red 1 0)))
(init (sees red (hand red 2 0)))
(init (sees red (hand red 3 0)))
(init (sees red (hand red 4 0)))
(init (sees red (hand red 5 0)))
(init (sees red (hand red 6 0)))
(init (sees red (hand red 7 0)))
(init (sees red (hand red 8 0)))
(init (sees red (hand red 9 0)))
(init (sees red (hand red 10 0)))

(init (sees blue (hand blue 1 0)))
(init (sees blue (hand blue 2 0)))
(init (sees blue (hand blue 3 0)))
(init (sees blue (hand blue 4 0)))
(init (sees blue (hand blue 5 0)))
(init (sees blue (hand blue 6 0)))
(init (sees blue (hand blue 7 0)))
(init (sees blue (hand blue 8 0)))
(init (sees blue (hand blue 9 0)))
(init (sees blue (hand blue 10 0)))

(init (sees green (hand green 1 0)))
(init (sees green (hand green 2 0)))
(init (sees green (hand green 3 0)))
(init (sees green (hand green 4 0)))
(init (sees green (hand green 5 0)))
(init (sees green (hand green 6 0)))
(init (sees green (hand green 7 0)))
(init (sees green (hand green 8 0)))
(init (sees green (hand green 9 0)))
(init (sees green (hand green 10 0)))

(init (sees yellow (hand yellow 1 0)))
(init (sees yellow (hand yellow 2 0)))
(init (sees yellow (hand yellow 3 0)))
(init (sees yellow (hand yellow 4 0)))
(init (sees yellow (hand yellow 5 0)))
(init (sees yellow (hand yellow 6 0)))
(init (sees yellow (hand yellow 7 0)))
(init (sees yellow (hand yellow 8 0)))
(init (sees yellow (hand yellow 9 0)))
(init (sees yellow (hand yellow 10 0)))
//TODO Hände random verteilen, Stapel auflegen-----------------------------------------------------------------------------------

//------------
//Stack Functions
//------------
(<= (isFull ?Stack)
    (not (true (stack ?stack 6 0)))
)
//TODO: isMatchingStack soll bestimmen, ob die Karte korrekt angelegt wurde, wenn es einen kleineren Stack gibt, muss es der größte davon sein, ansonsten true für beliebigen Stack

//Atleast one smaller stack
(<= (isMatchingStack ?stack ?card)
    (lastCard ?stack ?pos1 ?card1)
    (lastCard ?stack2 ?pos2 ?card2)
    (lastCard ?stack3 ?pos3 ?card3)
    (lastCard ?stack4 ?pos4 ?card4)
    (distinct ?stack ?stack2 ?stack3 ?stack4)
    //is ?card closest to ?stack ?
    (less ?card1 ?card)
    (not (between ?card2 ?card1 ?card))
    (not (between ?card3 ?card1 ?card))
    (not (between ?card4 ?card1 ?card))
)

//No smaller stack => any stack returns true
(<= (isMatchingStack ?stack ?card)
    (lastCard ?stack ?pos1 ?card1)
    (lastCard ?stack2 ?pos2 ?card2)
    (lastCard ?stack3 ?pos3 ?card3)
    (lastCard ?stack4 ?pos4 ?card4)
    (distinct ?stack ?stack2 ?stack3 ?stack4)
    (not (less ?card1 ?card))
    (not (less ?card2 ?card))
    (not (less ?card3 ?card))
    (not (less ?card4 ?card))
)

//Determine the last card in a stack
(<= (lastCard ?stack ?pos ?card)
    //following slot empty
    (succ ?pos ?posP)
    (true (stack ?stack ?posP 0))
    //?pos has a card
    (not (true (stack ?stack ?pos 0)))
    //previous slot filled
    (succ ?posM ?pos)
    (not (true (stack ?stack ?posM 0)))
)

//special case slot 1
(<= (lastCard ?stack ?pos ?card)
    (equal ?pos 1)
    (true (stack ?stack 1 ?card))
    (true (stack ?stack 2 0))
)

//Util Functions

//Determine if ?cardMiddle is greater than ?cardLeft and smaller than ?cardRight
(<= (between ?cardMiddle ?cardLeft ?cardRight)
    (less ?cardLeft ?cardMiddle)
    (less ?cardMiddle ?cardRight)
)

//determine the smallest card in Play
(<= (smallest ?card1)
    (true (inPlay ?player1 ?card1))
    (true (inPlay ?player2 ?card2))
    (true (inPlay ?player3 ?card3))
    (true (inPlay ?player4 ?card4))
    (distinct ?player1 ?player2 ?player3 ?player4)
    (less ?card1 ?card2)
    (less ?card1 ?card3)
    (less ?card1 ?card4)
)

//TODO anlegen der Karten-------------------------------------------------------------------------------------------------------------------------
//ggf anlegzüge nachschieben (aka Control an niedrigsten Spieler geben, dann aufwärts)
//(<= (cards_placed)
//    (does red (play ?card1))
//    (does blue (play ?card2))
//    (does green (play ?card3))
//    (does yellow (play ?card4))
//    (placedFirst ?card1 ?card2 ?card3 ?card4 ?placed1)
//    (placedSecond ?card1 ?card2 ?card3 ?card4 ?placed1 ?placed2)
//    (placedThird ?card1 ?card2 ?card3 ?card4 ?placed1 ?placed2 ?placed3)
//    (placedFourth ?card1 ?card2 ?card3 ?card4 ?placed1 ?placed2 ?placed3 ?placed4)
//)*/

//-------------
//Legal
//-------------

//define legal moves
//Karten dürfen nur gespielt werden, wenn alle spielen
(<= (legal ?player (play ?card))
    (isPlayer ?player)
    (isCard ?card ?val)
    (true (control all))
    (true (sees ?player (hand ?player ?pos ?card)))
)

//Anlegen
(<= (legal ?player (put ?card ?stack ?pos))
    (isPlayer ?player)
    (true (control ?player))
    (true (inPlay ?player ?card))
    (isMatchingStack ?stack ?card)
    (succ ?posP ?pos)
    (lastCard ?stack ?posP ?cardP)
    (less ?cardP ?card)
)

//Anlegen in slot 6 falls kein passender Stapel vorhanden war
(<= (legal ?player (put ?card ?stack 6))
    (isPlayer ?player)
    (true (control ?player))
    (true (inPlay ?player ?card))
    (isMatchingStack ?stack ?card)
    (lastCard ?stack ?posLast ?cardLast)
    (greater ?cardLast ?card)
)

//Kein Spieler hat einen freien Platz auf der Hand, Poisition 1 jedes Stapels ist belegt
(<= (legal random (gameReady))
    (true (control random))
    (isPlayer ?player)
    (not (true (stack ?num 1 0)))
    (not (true (sees ?player (hand ?player ?pos 0))))
)

(<= (legal random (deal stack ?num ?card))
    (true (control random))
    (isCard ?card ?val)
    (true (stack ?num 1 0))
    (not (true (dealt ?card)))
)

(<= (legal random (deal hand ?player ?pos ?card))
    (true (control random))
    (isPlayer ?player)
    (isCard ?card ?val)
    (true (sees ?player (hand ?player ?pos 0)))
    (not (true (dealt ?card)))
)
//TODO-----------------------------------------------------------------------------------------------------------------------

//-------------
//Build next state
//-------------

//handle dealt cards
(<= (next (dealt ?card))
    (true (dealt ?card))
    //discard flags to save space after random is done
    (true (control random))
)

(<= (next (dealt ?card))
    (does random (deal hand ?player ?pos ?card))
)

(<= (next (dealt ?card))
    (does random (deal stack ?num ?card))
)

(<= (next (sees ?player (hand ?player ?pos ?card)))
    (does random (deal hand ?player ?pos ?card))
)

(<= (next (stack ?num 1 ?card))
    (does random (deal stack ?num ?card))
)

(<= (next (control random))
    (not (does random (gameReady)))
    (true (control random))
)

(<= (next (control all))
    (does random (gameReady))
    (true (control random))
)
//TODO Gespielte Karten als inPlay codieren
//TODO inPlay kopieren bis angelegt
//TODO niedrigste Karte in play finden, control an den Spieler
//TODO wenn keine Karte in Play, control => all

//TODO: put Function

//place card
(<= (next (stack ?stack ?pos ?card))
    (does ?player (put ?card ?stack ?pos))
)

//handle inPlay flags
(<= (next (inPlay ?player ?card))
    (does ?player (play ?card))
)

//copy inPlay card while it's not beeing put
(<= (next (inPlay ?player ?card))
    (true (inPlay ?player ?card))
    (not (does ?player (put ?card ?stack)))
)

//remove card from inPlay when it's put
(<= (next (inPlay ?player 1000))
    (does ?player (put ?card ?stack))
)

//mark player as having no card in play
(<= (next (inPlay ?player 1000))
    (not (true (control all)))
    (isPlayer ?player)
    (not (does ?player (play ?card)))
    (not (true (inPlay ?player ?card1)))
    (distinct ?card1 1000)
)

//hand control to the player with the smallest card in play which isn't already placed (1000 = card was placed in a prior turn)
(<= (next (control ?player))
    (true (inPlay ?player ?card))
    (not (does ?player (put ?card ?stack)))
    (smallest ?card)
    (distinct ?card 1000)
)

//Letzter Spieler legt an
(<= (next (control all))
    (not (true (control all)))
    (does ?player1 (put ?card1 ?stack))
    (true (inPlay ?player2 ?card2))
    (true (inPlay ?player3 ?card3))
    (true (inPlay ?player4 ?card4))
    (distinct ?player1 ?player2 ?player3 ?player4)
    (equal ?card2 1000)
    (equal ?card3 1000)
    (equal ?card4 1000)
)

//Hands
//Copy all non played cards
(<= (next (sees ?player (hand ?player ?pos ?card)))
    (true (sees ?player (hand ?player ?pos ?card)))
    (not (does ?player (play ?card)))
    (not (does random (deal hand ?player ?pos ?card1)))
)
//Set all played cards in hand to zero
(<= (next (sees ?player (hand ?player ?pos 0)))
    (true (sees ?player (hand ?player ?pos ?card)))
    (does ?player (play ?card))
)

//points
(<= (next (points ?player ?card))
    (true (points ?player ?card))
)

//Copy Stacks and remove overflow
//Copy non full stacks 1 to 1
(<= (next (stack ?stack ?pos ?card))
    (true (stack ?stack ?pos ?card))
    (not (isFull ?stack))
    (not (does random (deal stack ?stack ?card1)))
)

(<= (next (stack ?stack ?pos ?card))
    (true (stack ?stack ?pos ?card))
    (not (isFull ?stack))
    (not (equal ?pos 1))
)

//Copy slots 6-9 into 1-4 if stack is full if they exist, If not write 0
(<= (next (stack ?stack 1 ?card))
    (true (stack ?stack 6 ?card))
    (isFull ?stack)
)

//(<= (next (stack ?Stack 2 ?card))
//    (true (stack ?Stack 7 ?card))
//    (isFull ?Stack)
//)

(<= (next (stack ?Stack 2 0))
//    (not(true (stack ?Stack 7 ?card)))
    (isFull ?Stack)
)

//(<= (next (stack ?Stack 3 ?card))
//    (true (stack ?Stack 8 ?card))
//    (isFull ?Stack)
//)

(<= (next (stack ?Stack 3 0))
//    (not(true (stack ?Stack 8 ?card)))
    (isFull ?Stack)
)

//(<= (next (stack ?Stack 4 ?card))
//    (true (stack ?Stack 9 ?card))
//    (isFull (?Stack))
//)

(<= (next (stack ?Stack 4 0))
    (not(true (stack ?Stack 9 ?card)))
    (isFull ?Stack)
)

//Empty slots 5 and 6 if stack was full
(<= (next (stack ?Stack 5 0))
    (isFull ?Stack)
)

(<= (next (stack ?Stack 6 0))
    (isFull ?Stack)
)

//apply Points gained by moving pos 1-5 to points
(<= (next (points ?player ?card1))
    (true (stack ?Stack 6 ?card))
    (does ?player (play ?card))
    (true (stack ?Stack 1 ?card1))
)

(<= (next (points ?player ?card2))
    (true (stack ?Stack 6 ?card))
    (does ?player (play ?card))
    (true (stack ?Stack 2 ?card2))
)

(<= (next (points ?player ?card3))
    (true (stack ?Stack 6 ?card))
    (does ?player (play ?card))
    (true (stack ?Stack 3 ?card3))
)

(<= (next (points ?player ?card4))
    (true (stack ?Stack 6 ?card))
    (does ?player (play ?card))
    (true (stack ?Stack 4 ?card4))
)

(<= (next (points ?player ?card5))
    (true (stack ?Stack 6 ?card))
    (does ?player (play ?card))
    (true (stack ?Stack 5 ?card5))
)

//------------
//Constants
//------------
//(isPlayer <player>)
(isPlayer red)
(isPlayer blue)
(isPlayer green)
(isPlayer yellow)

//(isCard <number> <points>)
(isCard 1 1)
(isCard 2 1)
(isCard 3 1)
(isCard 4 1)
(isCard 5 2)
(isCard 6 1)
(isCard 7 1)
(isCard 8 1)
(isCard 9 1)
(isCard 10 3)
(isCard 11 5)
(isCard 12 1)
(isCard 13 1)
(isCard 14 1)
(isCard 15 2)
(isCard 16 1)
(isCard 17 1)
(isCard 18 1)
(isCard 19 1)
(isCard 20 3)
(isCard 21 1)
(isCard 22 5)
(isCard 23 1)
(isCard 24 1)
(isCard 25 2)
(isCard 26 1)
(isCard 27 1)
(isCard 28 1)
(isCard 29 1)
(isCard 30 3)
(isCard 31 1)
(isCard 32 1)
(isCard 33 5)
(isCard 34 1)
(isCard 35 2)
(isCard 36 1)
(isCard 37 1)
(isCard 38 1)
(isCard 39 1)
(isCard 40 3)
(isCard 41 1)
(isCard 42 1)
(isCard 43 1)
(isCard 44 5)
(isCard 45 2)
(isCard 46 1)
(isCard 47 1)
(isCard 48 1)
(isCard 49 1)
(isCard 50 3)
(isCard 51 1)
(isCard 52 1)
(isCard 53 1)
(isCard 54 1)
(isCard 55 7)
(isCard 56 1)
(isCard 57 1)
(isCard 58 1)
(isCard 59 1)
(isCard 60 3)
(isCard 61 1)
(isCard 62 1)
(isCard 63 1)
(isCard 64 1)
(isCard 65 2)
(isCard 66 5)
(isCard 67 1)
(isCard 68 1)
(isCard 69 1)
(isCard 70 3)
(isCard 71 1)
(isCard 72 1)
(isCard 73 1)
(isCard 74 1)
(isCard 75 2)
(isCard 76 1)
(isCard 77 5)
(isCard 78 1)
(isCard 79 1)
(isCard 80 3)
(isCard 81 1)
(isCard 82 1)
(isCard 83 1)
(isCard 84 1)
(isCard 85 2)
(isCard 86 1)
(isCard 87 1)
(isCard 88 5)
(isCard 89 1)
(isCard 90 3)
(isCard 91 1)
(isCard 92 1)
(isCard 93 1)
(isCard 94 1)
(isCard 95 2)
(isCard 96 1)
(isCard 97 1)
(isCard 98 1)
(isCard 99 5)
(isCard 100 3)
(isCard 101 1)
(isCard 102 1)
(isCard 103 1)
(isCard 104 1)