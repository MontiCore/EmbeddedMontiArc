/* (c) https://github.com/MontiCore/monticore */
package cNNSegment;

component Network<Z(2:oo) num_classes = 10>{
    ports in Z(0:255)^{1, 56, 56} data,
         out Q(0:1)^{num_classes, 56, 56} softmax;

    implementation CNN{

        def conv(filter, channels){
            Convolution(kernel=(filter,filter), channels=channels) ->
            Relu()
        }

        def maxPool2dSamePadding(kernel, stride){
            Pooling(pool_type="max", kernel=kernel, stride=stride)
            //Crop(start=1, until=0)
        }

        def encode_block(num_conv, filter, channels){
            conv(filter=filter, channels=channels, ->=num_conv) ->
            maxPool2dSamePadding(kernel=(2,2), stride=(2,2))
        }

        def fully_conv(filter, channels, dropout) {
            conv(filter=filter, channels=channels) ->
            Relu() ->
            Dropout(p=dropout)
        }

        data ->

        /* encode block 1 */
        //encode_block(num_conv=2, filter=3, channels=64) ->

        /* encode block 2 */
        encode_block(num_conv=2, filter=3, channels=128) ->

        /* encode block 4 */
        encode_block(num_conv=3, filter=3, channels=256) ->
        (
            /* encode block 5 */
            encode_block(num_conv=3, filter=3, channels=256) ->

            /* fully convolutional layers, replacing fully connected layers */
            fully_conv(filter=7, channels=1028, dropout=0.5) ->
            fully_conv(filter=7, channels=1028, dropout=0.5) ->
            Convolution(kernel=(1,1), channels=num_classes) ->

            /* upsampling */
            TransConv(kernel=(4,4), channels=num_classes, stride=(2,2))
        |
            /* skip 4 */
            Convolution(kernel=(4,4), channels=num_classes)
        ) ->

        Concatenate() ->

        /*  Final up-sampling and cropping */
        TransConv(kernel=(8,8), channels=num_classes, stride=(4,4)) ->
        softmax;
    }
}