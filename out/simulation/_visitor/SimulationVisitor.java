/* generated by template visitor.SimpleVisitor*/



package simulation._visitor;

import java.util.Iterator;
import simulation._ast.ASTSimulationNode;
import de.monticore.ast.ASTNode;

/**
 * Default AST-visitor for the {@code Simulation} language.<br/>
 * <br/>
 * <b>Running a visitor</b>: Starting a traversal of an AST with root {@code astNode} is as simple as calling {@code handle(astNode)}. Note that the visitor only handles nodes of language {@code Simulation}.<br/>
 * <br/>
 * <b>Implementing a visitor:</b><br/>
 * You should never use {@code this}, but always make use of {@link #getRealThis()}. This ensures that the visitor can be reused by composition.<br/>
 * <br/>
 * <ul>
 *   <li><b>Visiting nodes</b>: You may override the {@code visit(node)} and {@code endVisit(node)} methods to do something at specific AST-nodes.<br/><br/></li>
 *   <li><b>Traversal</b>: You may override the {@code traverse(node)} methods, if you want to change the climb down strategy for traversing children (e.g. ordering the children). Be aware of the underlying double-dispatch mechanism: probably you want to call {@code childNode.accept(getRealThis())} and <b>not</b> {@code handle(childNode)}<br/><br/></li>
 *   <li><b>Handling of nodes</b>: You may override the {@code handle(node)} methods, if you want to change its default implementation (depth-first iteration): {@code visit(node); traverse(node); endVisit(node);}<br/><br/></li>
 * </ul>
 * <b>Special node type {@code ASTNode}:</b><br/>
 * Visitors do not provide handle or traverse methods for {@code ASTNode},
 * because handling and traversal are defined in the language depending node
 * types. However, an {@link SimulationInheritanceVisitor} visits and
 * endVisits each node as {@code ASTNode}. Due to composition of all kinds of
 * visitors we must define the methods here in the main visitor interface.
 *
 * @see ASTSimulationNode#accept(SimulationVisitor visitor)
 */
public interface SimulationVisitor  extends weather._visitor.WeatherVisitor, si._visitor.SIVisitor {

  /**
   * Sets the visitor to use for handling and traversing nodes.
   * This method is not implemented by default and visitors intended for reusage
   * in other languages should override this method together with
   * {@link #getRealThis()} to make a visitor composable.
   * RealThis is used to allow visitor composition, where a delegating visitor
   * utilizes this setter to set another visitor as the handle/traversal
   * controller. If this method is not overridden by the language developer,
   * the visitor still can be reused, by implementing this method in a
   * decorator.
   * @param realThis the real instance to use for handling and traversing nodes.
   * @see SimulationDelegatorVisitor 
   */
  default public void setRealThis(SimulationVisitor realThis) {
    throw new UnsupportedOperationException("0xA7011_645 The setter for realThis is not implemented. You might want to implement a wrapper class to allow setting/getting realThis.");
  }

  /**
   * By default this method returns {@code this}. Visitors intended for reusage
   * in other languages should override this method together with
   * {@link #setRealThis(SimulationVisitor)} to make a visitor
   * composable.
   * See {@link #setRealThis(SimulationVisitor)} for more information.
   * @see #setRealThis(SimulationVisitor)
   * @see SimulationDelegatorVisitor
   */
  default public SimulationVisitor getRealThis() {
    return this;
  }
  
  /* ------------------------------------------------------------------------*/
  
  /**
   * By default this method is not called, because the default visitor only
   * visits a node in its dynamic runtime type. Use an InheritanceVisitor
   * if you want to visit a node in its super types as well.
   *
   * @param node the node that is entered 
   */
  default public void visit(ASTNode node) {
  }

  /**
   * By default this method is not called, because the default visitor only
   * visits a node in its dynamic runtime type. Use an InheritanceVisitor
   * if you want to visit a node in its super types as well.
   *
   * @param node the node that is left 
   */
  default public void endVisit(ASTNode node) {
  }
  
  /* ------------------------------------------------------------------------*/
  
  
      
      default public void visit(simulation._ast.ASTSimulation node) {}
      
      default public void endVisit(simulation._ast.ASTSimulation node) {}
      
      default public void handle(simulation._ast.ASTSimulation node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTSimulation node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (node.getSimulationRenderFrequency().isPresent()) {
                  node.getSimulationRenderFrequency().get().accept(getRealThis());
                }
                if (node.getSimulationLoopFrequency().isPresent()) {
                  node.getSimulationLoopFrequency().get().accept(getRealThis());
                }
                if (node.getSimulationDuration().isPresent()) {
                  node.getSimulationDuration().get().accept(getRealThis());
                }
                if (node.getSimulationType().isPresent()) {
                  node.getSimulationType().get().accept(getRealThis());
                }
                if (node.getWeather().isPresent()) {
                  node.getWeather().get().accept(getRealThis());
                }
                if (node.getTime().isPresent()) {
                  node.getTime().get().accept(getRealThis());
                }
                if (node.getMapPath().isPresent()) {
                  node.getMapPath().get().accept(getRealThis());
                }
                if (null != node.getMapName()) {          
                  node.getMapName().accept(getRealThis());
                }
                if (node.getMapHeight().isPresent()) {
                  node.getMapHeight().get().accept(getRealThis());
                }
                if (node.getMapOverlap().isPresent()) {
                  node.getMapOverlap().get().accept(getRealThis());
                }
                if (node.getMapSectorWidth().isPresent()) {
                  node.getMapSectorWidth().get().accept(getRealThis());
                }
                if (node.getMapSectorHeight().isPresent()) {
                  node.getMapSectorHeight().get().accept(getRealThis());
                }
                if (node.getMaxSectorUsers().isPresent()) {
                  node.getMaxSectorUsers().get().accept(getRealThis());
                }
                if (node.getTimeout().isPresent()) {
                  node.getTimeout().get().accept(getRealThis());
                }
                if (node.getPedestrians().isPresent()) {
                  node.getPedestrians().get().accept(getRealThis());
                }
                if (node.getPedestrianDensity().isPresent()) {
                  node.getPedestrianDensity().get().accept(getRealThis());
                }
                if (node.getVehicles().isPresent()) {
                  node.getVehicles().get().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTSimulationRenderFrequency node) {}
      
      default public void endVisit(simulation._ast.ASTSimulationRenderFrequency node) {}
      
      default public void handle(simulation._ast.ASTSimulationRenderFrequency node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTSimulationRenderFrequency node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getSimRenderFreq()) {          
                  node.getSimRenderFreq().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTSimulationLoopFrequency node) {}
      
      default public void endVisit(simulation._ast.ASTSimulationLoopFrequency node) {}
      
      default public void handle(simulation._ast.ASTSimulationLoopFrequency node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTSimulationLoopFrequency node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getSimLoopFreq()) {          
                  node.getSimLoopFreq().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTSimulationDuration node) {}
      
      default public void endVisit(simulation._ast.ASTSimulationDuration node) {}
      
      default public void handle(simulation._ast.ASTSimulationDuration node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTSimulationDuration node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getSimDuration()) {          
                  node.getSimDuration().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTSimulationType node) {}
      
      default public void endVisit(simulation._ast.ASTSimulationType node) {}
      
      default public void handle(simulation._ast.ASTSimulationType node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTSimulationType node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTWeatherObj node) {}
      
      default public void endVisit(simulation._ast.ASTWeatherObj node) {}
      
      default public void handle(simulation._ast.ASTWeatherObj node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTWeatherObj node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getTemperature()) {          
                  node.getTemperature().accept(getRealThis());
                }
                if (null != node.getClouding()) {          
                  node.getClouding().accept(getRealThis());
                }
                if (null != node.getSight()) {          
                  node.getSight().accept(getRealThis());
                }
                if (null != node.getPrecipitationtype()) {          
                  node.getPrecipitationtype().accept(getRealThis());
                }
                if (node.getHumidity().isPresent()) {
                  node.getHumidity().get().accept(getRealThis());
                }
                if (node.getPressure().isPresent()) {
                  node.getPressure().get().accept(getRealThis());
                }
                if (node.getWindstrength().isPresent()) {
                  node.getWindstrength().get().accept(getRealThis());
                }
                if (node.getWinddirection().isPresent()) {
                  node.getWinddirection().get().accept(getRealThis());
                }
                if (node.getPrecipitationamount().isPresent()) {
                  node.getPrecipitationamount().get().accept(getRealThis());
                }
              {
                Iterator<weather._ast.ASTWeatherPhenomena> iter_weatherPhenomenas = node.getWeatherPhenomenas().iterator();
                while (iter_weatherPhenomenas.hasNext()) {
                  iter_weatherPhenomenas.next().accept(getRealThis());
                }
              }
              {
                Iterator<weather._ast.ASTOpticalPhenomena> iter_opticalPhenomenas = node.getOpticalPhenomenas().iterator();
                while (iter_opticalPhenomenas.hasNext()) {
                  iter_opticalPhenomenas.next().accept(getRealThis());
                }
              }
              {
                Iterator<weather._ast.ASTArtificialPhenomena> iter_artificialPhenomenas = node.getArtificialPhenomenas().iterator();
                while (iter_artificialPhenomenas.hasNext()) {
                  iter_artificialPhenomenas.next().accept(getRealThis());
                }
              }
      }
      
      default public void visit(simulation._ast.ASTWeather node) {}
      
      default public void endVisit(simulation._ast.ASTWeather node) {}
      
      default public void handle(simulation._ast.ASTWeather node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTWeather node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (node.getFixedWeather().isPresent()) {
                  node.getFixedWeather().get().accept(getRealThis());
                }
                if (node.getSequenceWeather().isPresent()) {
                  node.getSequenceWeather().get().accept(getRealThis());
                }
                if (node.getRandomWeather().isPresent()) {
                  node.getRandomWeather().get().accept(getRealThis());
                }
                if (node.getForecast().isPresent()) {
                  node.getForecast().get().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTFixedWeather node) {}
      
      default public void endVisit(simulation._ast.ASTFixedWeather node) {}
      
      default public void handle(simulation._ast.ASTFixedWeather node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTFixedWeather node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getFixedWeatherObj()) {          
                  node.getFixedWeatherObj().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTSequenceWeather node) {}
      
      default public void endVisit(simulation._ast.ASTSequenceWeather node) {}
      
      default public void handle(simulation._ast.ASTSequenceWeather node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTSequenceWeather node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

              {
                Iterator<simulation._ast.ASTWeatherObj> iter_randomWeatherObj = node.getRandomWeatherObj().iterator();
                while (iter_randomWeatherObj.hasNext()) {
                  iter_randomWeatherObj.next().accept(getRealThis());
                }
              }
                if (node.getSequenceDuration().isPresent()) {
                  node.getSequenceDuration().get().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTRandomWeather node) {}
      
      default public void endVisit(simulation._ast.ASTRandomWeather node) {}
      
      default public void handle(simulation._ast.ASTRandomWeather node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTRandomWeather node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getRandomDuration()) {          
                  node.getRandomDuration().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTForecast node) {}
      
      default public void endVisit(simulation._ast.ASTForecast node) {}
      
      default public void handle(simulation._ast.ASTForecast node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTForecast node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getForecastWeatherObj()) {          
                  node.getForecastWeatherObj().accept(getRealThis());
                }
                if (null != node.getForecastDuration()) {          
                  node.getForecastDuration().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTTime node) {}
      
      default public void endVisit(simulation._ast.ASTTime node) {}
      
      default public void handle(simulation._ast.ASTTime node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTTime node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (node.getUnitNumber().isPresent()) {
                  node.getUnitNumber().get().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTMapPath node) {}
      
      default public void endVisit(simulation._ast.ASTMapPath node) {}
      
      default public void handle(simulation._ast.ASTMapPath node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMapPath node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTMapName node) {}
      
      default public void endVisit(simulation._ast.ASTMapName node) {}
      
      default public void handle(simulation._ast.ASTMapName node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMapName node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTMapHeight node) {}
      
      default public void endVisit(simulation._ast.ASTMapHeight node) {}
      
      default public void handle(simulation._ast.ASTMapHeight node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMapHeight node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTMapOverlap node) {}
      
      default public void endVisit(simulation._ast.ASTMapOverlap node) {}
      
      default public void handle(simulation._ast.ASTMapOverlap node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMapOverlap node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTMapSectorWidth node) {}
      
      default public void endVisit(simulation._ast.ASTMapSectorWidth node) {}
      
      default public void handle(simulation._ast.ASTMapSectorWidth node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMapSectorWidth node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTMapSectorHeight node) {}
      
      default public void endVisit(simulation._ast.ASTMapSectorHeight node) {}
      
      default public void handle(simulation._ast.ASTMapSectorHeight node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMapSectorHeight node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTMaxSectorUsers node) {}
      
      default public void endVisit(simulation._ast.ASTMaxSectorUsers node) {}
      
      default public void handle(simulation._ast.ASTMaxSectorUsers node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTMaxSectorUsers node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

      }
      
      default public void visit(simulation._ast.ASTTimeout node) {}
      
      default public void endVisit(simulation._ast.ASTTimeout node) {}
      
      default public void handle(simulation._ast.ASTTimeout node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTTimeout node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getTimeout()) {          
                  node.getTimeout().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTPedestrians node) {}
      
      default public void endVisit(simulation._ast.ASTPedestrians node) {}
      
      default public void handle(simulation._ast.ASTPedestrians node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTPedestrians node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

              {
                Iterator<si._ast.ASTUnitNumber> iter_startX = node.getStartX().iterator();
                while (iter_startX.hasNext()) {
                  iter_startX.next().accept(getRealThis());
                }
              }
              {
                Iterator<si._ast.ASTUnitNumber> iter_startY = node.getStartY().iterator();
                while (iter_startY.hasNext()) {
                  iter_startY.next().accept(getRealThis());
                }
              }
              {
                Iterator<si._ast.ASTUnitNumber> iter_endX = node.getEndX().iterator();
                while (iter_endX.hasNext()) {
                  iter_endX.next().accept(getRealThis());
                }
              }
              {
                Iterator<si._ast.ASTUnitNumber> iter_endY = node.getEndY().iterator();
                while (iter_endY.hasNext()) {
                  iter_endY.next().accept(getRealThis());
                }
              }
              {
                Iterator<si._ast.ASTUnitNumber> iter_endZ = node.getEndZ().iterator();
                while (iter_endZ.hasNext()) {
                  iter_endZ.next().accept(getRealThis());
                }
              }
      }
      
      default public void visit(simulation._ast.ASTPedestrianDensity node) {}
      
      default public void endVisit(simulation._ast.ASTPedestrianDensity node) {}
      
      default public void handle(simulation._ast.ASTPedestrianDensity node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTPedestrianDensity node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getPedestrianDensity()) {          
                  node.getPedestrianDensity().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTVehicles node) {}
      
      default public void endVisit(simulation._ast.ASTVehicles node) {}
      
      default public void handle(simulation._ast.ASTVehicles node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTVehicles node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

              {
                Iterator<simulation._ast.ASTExplicitVehicle> iter_explicitVehicles = node.getExplicitVehicles().iterator();
                while (iter_explicitVehicles.hasNext()) {
                  iter_explicitVehicles.next().accept(getRealThis());
                }
              }
              {
                Iterator<simulation._ast.ASTPathedVehicle> iter_pathedVehicles = node.getPathedVehicles().iterator();
                while (iter_pathedVehicles.hasNext()) {
                  iter_pathedVehicles.next().accept(getRealThis());
                }
              }
              {
                Iterator<simulation._ast.ASTRandomVehicle> iter_randomVehicles = node.getRandomVehicles().iterator();
                while (iter_randomVehicles.hasNext()) {
                  iter_randomVehicles.next().accept(getRealThis());
                }
              }
      }
      
      default public void visit(simulation._ast.ASTExplicitVehicle node) {}
      
      default public void endVisit(simulation._ast.ASTExplicitVehicle node) {}
      
      default public void handle(simulation._ast.ASTExplicitVehicle node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTExplicitVehicle node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getStartX()) {          
                  node.getStartX().accept(getRealThis());
                }
                if (null != node.getStartY()) {          
                  node.getStartY().accept(getRealThis());
                }
                if (null != node.getStartRot()) {          
                  node.getStartRot().accept(getRealThis());
                }
                if (null != node.getDestX()) {          
                  node.getDestX().accept(getRealThis());
                }
                if (null != node.getDestY()) {          
                  node.getDestY().accept(getRealThis());
                }
                if (null != node.getDestZ()) {          
                  node.getDestZ().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTPathedVehicle node) {}
      
      default public void endVisit(simulation._ast.ASTPathedVehicle node) {}
      
      default public void handle(simulation._ast.ASTPathedVehicle node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTPathedVehicle node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (null != node.getSpawnX()) {          
                  node.getSpawnX().accept(getRealThis());
                }
                if (null != node.getSpawnY()) {          
                  node.getSpawnY().accept(getRealThis());
                }
                if (null != node.getSpawnRadius()) {          
                  node.getSpawnRadius().accept(getRealThis());
                }
                if (null != node.getDestX()) {          
                  node.getDestX().accept(getRealThis());
                }
                if (null != node.getDestY()) {          
                  node.getDestY().accept(getRealThis());
                }
                if (null != node.getDestRadius()) {          
                  node.getDestRadius().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTRandomVehicle node) {}
      
      default public void endVisit(simulation._ast.ASTRandomVehicle node) {}
      
      default public void handle(simulation._ast.ASTRandomVehicle node) {
        getRealThis().visit(node);
          getRealThis().traverse(node);
        getRealThis().endVisit(node);
      }
    
      default public void traverse(simulation._ast.ASTRandomVehicle node) {
        // One might think that we could call traverse(subelement) immediately,
        // but this is not true for interface-types where we do not know the
        // concrete type of the element.
        // Instead we double-dispatch the call, to call the correctly typed
        // traverse(...) method with the elements concrete type.

                if (node.getStartX().isPresent()) {
                  node.getStartX().get().accept(getRealThis());
                }
                if (node.getStartY().isPresent()) {
                  node.getStartY().get().accept(getRealThis());
                }
                if (node.getDestX().isPresent()) {
                  node.getDestX().get().accept(getRealThis());
                }
                if (node.getDestY().isPresent()) {
                  node.getDestY().get().accept(getRealThis());
                }
      }
      
      default public void visit(simulation._ast.ASTSimulationNode node) {}
      
      default public void endVisit(simulation._ast.ASTSimulationNode node) {}
      
      default public void handle(simulation._ast.ASTSimulationNode node) {
        getRealThis().visit(node);
        // no traverse() for interfaces and enums, only concrete classes are traversed
        getRealThis().endVisit(node);
      }
    
    
}
