/* generated by template parser.Parser*/

// Generated antlr file

// Parser header
/* generated by template parser.ParserHeader*/
grammar SimulationAntlr;
@parser::header {
package simulation._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package simulation._parser;
}
options {
superClass=MCParser;
}

@parser::members

{
// Global actions

// Convert functions
  // convert function for TFloatPointUnitNumber
private String convertTFloatPointUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for Significant
private String convertSignificant(Token t)  {
    return t.getText();
}

  // convert function for THexUnitNumber
private String convertTHexUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitNumber
private String convertTUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitInf
private String convertTUnitInf(Token t)  {
    return t.getText();
}

  // convert function for TComplexNumber
private String convertTComplexNumber(Token t)  {
    return t.getText();
}

  // convert function for RealNumber
private String convertRealNumber(Token t)  {
    return t.getText();
}

  // convert function for PosNumber
private String convertPosNumber(Token t)  {
    return t.getText();
}

  // convert function for PosInt
private String convertPosInt(Token t)  {
    return t.getText();
}

  // convert function for UngroupedPosInt
private String convertUngroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for GroupedPosInt
private String convertGroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for PosIntGroup
private String convertPosIntGroup(Token t)  {
    return t.getText();
}

  // convert function for Unit
private String convertUnit(Token t)  {
    return t.getText();
}

  // convert function for ImperialUnit
private String convertImperialUnit(Token t)  {
    return t.getText();
}

  // convert function for OfficallyAcceptedUnit
private String convertOfficallyAcceptedUnit(Token t)  {
    return t.getText();
}

  // convert function for SIUnit
private String convertSIUnit(Token t)  {
    return t.getText();
}

  // convert function for UnitPrefix
private String convertUnitPrefix(Token t)  {
    return t.getText();
}

  // convert function for SiUnitBaseDimension
private String convertSiUnitBaseDimension(Token t)  {
    return t.getText();
}

  // convert function for SiUnitDimensionless
private String convertSiUnitDimensionless(Token t)  {
    return t.getText();
}

  // convert function for Space
private String convertSpace(Token t)  {
    return t.getText();
}

  // convert function for NamePart
private String convertNamePart(Token t)  {
    return t.getText();
}

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for Numb
private String convertNumb(Token t)  {
    return t.getText();
}

  // convert function for PosNum
private String convertPosNum(Token t)  {
    return t.getText();
}

  // convert function for TElementType
private String convertTElementType(Token t)  {
    return t.getText();
}

}

// Lexer header
/* generated by template parser.LexerMember*/


@lexer::members {

// Add additional Java Code to lexer

private de.monticore.antlr4.MCParser _monticore_parser;
protected de.monticore.antlr4.MCParser getCompiler() {
   return _monticore_parser;
}
public void setMCParser(de.monticore.antlr4.MCParser in) {
  this._monticore_parser = in;
}
}


// Global actions

// Parser rules 
  
 // Start of 'ASTClassProd Number'


number_eof returns [si._ast.ASTNumber ret = null] :
  tmp = number {$ret = $tmp.ret;} EOF ;


  number returns [si._ast.ASTNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=floatPointUnitNumber{_aNode.setFloatPointUnitNumber(_localctx.tmp0.ret);}  
  
  |
   tmp1=hexUnitNumber{_aNode.setHexUnitNumber(_localctx.tmp1.ret);}  
  
  |
   tmp2=complexNumber{_aNode.setComplexNumber(_localctx.tmp2.ret);}  
  
  |
   tmp3=unitNumber{_aNode.setUnitNumber(_localctx.tmp3.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd FloatPointUnitNumber'


floatPointUnitNumber_eof returns [si._ast.ASTFloatPointUnitNumber ret = null] :
  tmp = floatPointUnitNumber {$ret = $tmp.ret;} EOF ;


  floatPointUnitNumber returns [si._ast.ASTFloatPointUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTFloatPointUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTFloatPointUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TFloatPointUnitNumber{_aNode.setTFloatPointUnitNumber(convertTFloatPointUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd HexUnitNumber'


hexUnitNumber_eof returns [si._ast.ASTHexUnitNumber ret = null] :
  tmp = hexUnitNumber {$ret = $tmp.ret;} EOF ;


  hexUnitNumber returns [si._ast.ASTHexUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTHexUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTHexUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=THexUnitNumber{_aNode.setTHexUnitNumber(convertTHexUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd UnitNumber'


unitNumber_eof returns [si._ast.ASTUnitNumber ret = null] :
  tmp = unitNumber {$ret = $tmp.ret;} EOF ;


  unitNumber returns [si._ast.ASTUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TUnitNumber{_aNode.setTUnitNumber(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexNumber'


complexNumber_eof returns [si._ast.ASTComplexNumber ret = null] :
  tmp = complexNumber {$ret = $tmp.ret;} EOF ;


  complexNumber returns [si._ast.ASTComplexNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTComplexNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTComplexNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TComplexNumber{_aNode.setTComplexNumber(convertTComplexNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Temperature'


temperature_eof returns [weather._ast.ASTTemperature ret = null] :
  tmp = temperature {$ret = $tmp.ret;} EOF ;


  temperature returns [weather._ast.ASTTemperature ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTTemperature _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTTemperature();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal temperature'
(TEMPERATURE)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherTemperature(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Humidity'


humidity_eof returns [weather._ast.ASTHumidity ret = null] :
  tmp = humidity {$ret = $tmp.ret;} EOF ;


  humidity returns [weather._ast.ASTHumidity ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTHumidity _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTHumidity();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal humidity'
(HUMIDITY)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherHumidity(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Pressure'


pressure_eof returns [weather._ast.ASTPressure ret = null] :
  tmp = pressure {$ret = $tmp.ret;} EOF ;


  pressure returns [weather._ast.ASTPressure ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPressure _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPressure();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal pressure'
(PRESSURE)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherPressure(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Windstrength'


windstrength_eof returns [weather._ast.ASTWindstrength ret = null] :
  tmp = windstrength {$ret = $tmp.ret;} EOF ;


  windstrength returns [weather._ast.ASTWindstrength ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWindstrength _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWindstrength();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal windstrength'
(WINDSTRENGTH)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherWindstrength(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Winddirection'


winddirection_eof returns [weather._ast.ASTWinddirection ret = null] :
  tmp = winddirection {$ret = $tmp.ret;} EOF ;


  winddirection returns [weather._ast.ASTWinddirection ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWinddirection _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWinddirection();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal winddirection'
(WINDDIRECTION)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherWinddirection(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Precipitationtype'


precipitationtype_eof returns [weather._ast.ASTPrecipitationtype ret = null] :
  tmp = precipitationtype {$ret = $tmp.ret;} EOF ;


  precipitationtype returns [weather._ast.ASTPrecipitationtype ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPrecipitationtype _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPrecipitationtype();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal precipitation_type'
('precipitation_type')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal none'
(NONE)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal drizzle'
(DRIZZLE)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal rain'
(RAIN)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal freezing drizzle'
('freezing drizzle')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal freezing rain'
('freezing rain')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow rain'
('snow rain')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snain'
(SNAIN)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow'
(SNOW)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow grains'
('snow grains')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal ice pellets'
('ice pellets')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal sleet'
(SLEET)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal hail'
(HAIL)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal snow pellets'
('snow pellets')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal graupel'
(GRAUPEL)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal ice crystals'
('ice crystals')// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Precipitationamount'


precipitationamount_eof returns [weather._ast.ASTPrecipitationamount ret = null] :
  tmp = precipitationamount {$ret = $tmp.ret;} EOF ;


  precipitationamount returns [weather._ast.ASTPrecipitationamount ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPrecipitationamount _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPrecipitationamount();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal precipitation_amount'
('precipitation_amount')// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setWeatherPrecipitationamount(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Clouding'


clouding_eof returns [weather._ast.ASTClouding ret = null] :
  tmp = clouding {$ret = $tmp.ret;} EOF ;


  clouding returns [weather._ast.ASTClouding ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTClouding _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTClouding();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal clouding'
(CLOUDING)// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal cirrostratus'
(CIRROSTRATUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal altostratus'
(ALTOSTRATUS)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal stratus'
(STRATUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal nimbostratus'
(NIMBOSTRATUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal noctilucent'
(NOCTILUCENT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal polar stratospheric'
('polar stratospheric')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cirrus'
(CIRRUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cirrocumulus'
(CIRROCUMULUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal altocumulus'
(ALTOCUMULUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal stratocumulus'
(STRATOCUMULUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulus humilis'
('cumulus humilis')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulus mediocris'
('cumulus mediocris')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulus congestus'
('cumulus congestus')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cumulonimbus'
(CUMULONIMBUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal none'
(NONE)// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Sight'


sight_eof returns [weather._ast.ASTSight ret = null] :
  tmp = sight {$ret = $tmp.ret;} EOF ;


  sight returns [weather._ast.ASTSight ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTSight _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTSight();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sight'
(SIGHT)// End of 'ASTTerminal'

  (
  
   tmp0=unitNumber{_aNode.setWeatherSight(_localctx.tmp0.ret);}  
  
  |
  
 // Start of 'ASTTerminal unlimited'
(UNLIMITED)// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd WeatherPhenomena'


weatherPhenomena_eof returns [weather._ast.ASTWeatherPhenomena ret = null] :
  tmp = weatherPhenomena {$ret = $tmp.ret;} EOF ;


  weatherPhenomena returns [weather._ast.ASTWeatherPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWeatherPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWeatherPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal weather_phenomena'
('weather_phenomena')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal fog'
(FOG)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal rope tornado'
('rope tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal cone tornado'
('cone tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal wedge tornado'
('wedge tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal multi-vortex tornado'
('multi-vortex tornado')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal landspout'
(LANDSPOUT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal waterspout'
(WATERSPOUT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal gustnado'
(GUSTNADO)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal dust devil'
('dust devil')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal steam devil'
('steam devil')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal thunderstorm'
(THUNDERSTORM)// End of 'ASTTerminal'

  
)
  (
  
  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

  (
  
  (tmp0=Numb{_aNode.setPosX(convertNumb($tmp0));}

  ) 
  
  
)
  (
  
  (tmp1=Numb{_aNode.setPosY(convertNumb($tmp1));}

  ) 
  
  
)
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)?
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd OpticalPhenomena'


opticalPhenomena_eof returns [weather._ast.ASTOpticalPhenomena ret = null] :
  tmp = opticalPhenomena {$ret = $tmp.ret;} EOF ;


  opticalPhenomena returns [weather._ast.ASTOpticalPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTOpticalPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTOpticalPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal optical_phenomena'
('optical_phenomena')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal rainbow'
(RAINBOW)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal northern lights'
('northern lights')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal circumzenithal arc'
('circumzenithal arc')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal zodiacal light'
('zodiacal light')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal crepuscular rays'
('crepuscular rays')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal mirage'
(MIRAGE)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal fog bow'
('fog bow')// End of 'ASTTerminal'

  
)
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ArtificialPhenomena'


artificialPhenomena_eof returns [weather._ast.ASTArtificialPhenomena ret = null] :
  tmp = artificialPhenomena {$ret = $tmp.ret;} EOF ;


  artificialPhenomena returns [weather._ast.ASTArtificialPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTArtificialPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTArtificialPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal artificial_phenomena'
('artificial_phenomena')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal contrails'
(CONTRAILS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal smog'
(SMOG)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal rocket exhaust trails'
('rocket exhaust trails')// End of 'ASTTerminal'

  
)
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Simulation'


simulation_eof returns [simulation._ast.ASTSimulation ret = null] :
  tmp = simulation {$ret = $tmp.ret;} EOF ;


  simulation returns [simulation._ast.ASTSimulation ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTSimulation _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTSimulation();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sim'
(SIM)// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal {'
(LCURLY)// End of 'ASTTerminal'

  ( tmp1=simulationRenderFrequency{_aNode.setSimulationRenderFrequency(_localctx.tmp1.ret);}) ? 
  
  ( tmp2=simulationLoopFrequency{_aNode.setSimulationLoopFrequency(_localctx.tmp2.ret);}) ? 
  
  ( tmp3=simulationDuration{_aNode.setSimulationDuration(_localctx.tmp3.ret);}) ? 
  
  ( tmp4=simulationType{_aNode.setSimulationType(_localctx.tmp4.ret);}) ? 
  
  ( tmp5=weather{_aNode.setWeather(_localctx.tmp5.ret);}) ? 
  
  ( tmp6=time{_aNode.setTime(_localctx.tmp6.ret);}) ? 
  
  ( tmp7=mapPath{_aNode.setMapPath(_localctx.tmp7.ret);}) ? 
  
   tmp8=mapName{_aNode.setMapName(_localctx.tmp8.ret);}  
  
  ( tmp9=mapHeight{_aNode.setMapHeight(_localctx.tmp9.ret);}) ? 
  
  ( tmp10=mapOverlap{_aNode.setMapOverlap(_localctx.tmp10.ret);}) ? 
  
  ( tmp11=mapSectorWidth{_aNode.setMapSectorWidth(_localctx.tmp11.ret);}) ? 
  
  ( tmp12=mapSectorHeight{_aNode.setMapSectorHeight(_localctx.tmp12.ret);}) ? 
  
  ( tmp13=maxSectorUsers{_aNode.setMaxSectorUsers(_localctx.tmp13.ret);}) ? 
  
  ( tmp14=timeout{_aNode.setTimeout(_localctx.tmp14.ret);}) ? 
  
  ( tmp15=pedestrians{_aNode.setPedestrians(_localctx.tmp15.ret);}) ? 
  
  ( tmp16=pedestrianDensity{_aNode.setPedestrianDensity(_localctx.tmp16.ret);}) ? 
  
  ( tmp17=vehicles{_aNode.setVehicles(_localctx.tmp17.ret);}) ? 
  
  
 // Start of 'ASTTerminal }'
(RCURLY)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SimulationRenderFrequency'


simulationRenderFrequency_eof returns [simulation._ast.ASTSimulationRenderFrequency ret = null] :
  tmp = simulationRenderFrequency {$ret = $tmp.ret;} EOF ;


  simulationRenderFrequency returns [simulation._ast.ASTSimulationRenderFrequency ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTSimulationRenderFrequency _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTSimulationRenderFrequency();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sim_render_frequency'
('sim_render_frequency')// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setSimRenderFreq(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SimulationLoopFrequency'


simulationLoopFrequency_eof returns [simulation._ast.ASTSimulationLoopFrequency ret = null] :
  tmp = simulationLoopFrequency {$ret = $tmp.ret;} EOF ;


  simulationLoopFrequency returns [simulation._ast.ASTSimulationLoopFrequency ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTSimulationLoopFrequency _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTSimulationLoopFrequency();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sim_loop_frequency'
('sim_loop_frequency')// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setSimLoopFreq(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SimulationDuration'


simulationDuration_eof returns [simulation._ast.ASTSimulationDuration ret = null] :
  tmp = simulationDuration {$ret = $tmp.ret;} EOF ;


  simulationDuration returns [simulation._ast.ASTSimulationDuration ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTSimulationDuration _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTSimulationDuration();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sim_duration'
('sim_duration')// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setSimDuration(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SimulationType'


simulationType_eof returns [simulation._ast.ASTSimulationType ret = null] :
  tmp = simulationType {$ret = $tmp.ret;} EOF ;


  simulationType returns [simulation._ast.ASTSimulationType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTSimulationType _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTSimulationType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sim_type'
('sim_type')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal fixed'
(FIXED)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal real-time'
('real-time')// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal max-fps'
('max-fps')// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd WeatherObj'


weatherObj_eof returns [simulation._ast.ASTWeatherObj ret = null] :
  tmp = weatherObj {$ret = $tmp.ret;} EOF ;


  weatherObj returns [simulation._ast.ASTWeatherObj ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTWeatherObj _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTWeatherObj();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal {'
(LCURLY)// End of 'ASTTerminal'

   tmp0=temperature{_aNode.setTemperature(_localctx.tmp0.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=clouding{_aNode.setClouding(_localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp2=sight{_aNode.setSight(_localctx.tmp2.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp3=precipitationtype{_aNode.setPrecipitationtype(_localctx.tmp3.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp4=humidity{_aNode.setHumidity(_localctx.tmp4.ret);}  
  
  
)?
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp5=pressure{_aNode.setPressure(_localctx.tmp5.ret);}  
  
  
)?
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp6=windstrength{_aNode.setWindstrength(_localctx.tmp6.ret);}  
  
  
)?
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp7=winddirection{_aNode.setWinddirection(_localctx.tmp7.ret);}  
  
  
)?
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp8=precipitationamount{_aNode.setPrecipitationamount(_localctx.tmp8.ret);}  
  
  
)?
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp9=weatherPhenomena{addToIteratedAttributeIfNotNull(_aNode.getWeatherPhenomenas(), _localctx.tmp9.ret);}  
  
  
)*
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp10=opticalPhenomena{addToIteratedAttributeIfNotNull(_aNode.getOpticalPhenomenas(), _localctx.tmp10.ret);}  
  
  
)*
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp11=artificialPhenomena{addToIteratedAttributeIfNotNull(_aNode.getArtificialPhenomenas(), _localctx.tmp11.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
(RCURLY)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Weather'


weather_eof returns [simulation._ast.ASTWeather ret = null] :
  tmp = weather {$ret = $tmp.ret;} EOF ;


  weather returns [simulation._ast.ASTWeather ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTWeather _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTWeather();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal weather'
(WEATHER)// End of 'ASTTerminal'

  (
  
   tmp0=fixedWeather{_aNode.setFixedWeather(_localctx.tmp0.ret);}  
  
  |
   tmp1=sequenceWeather{_aNode.setSequenceWeather(_localctx.tmp1.ret);}  
  
  |
   tmp2=randomWeather{_aNode.setRandomWeather(_localctx.tmp2.ret);}  
  
  |
   tmp3=forecast{_aNode.setForecast(_localctx.tmp3.ret);}  
  
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd FixedWeather'


fixedWeather_eof returns [simulation._ast.ASTFixedWeather ret = null] :
  tmp = fixedWeather {$ret = $tmp.ret;} EOF ;


  fixedWeather returns [simulation._ast.ASTFixedWeather ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTFixedWeather _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTFixedWeather();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal fixed'
(FIXED)// End of 'ASTTerminal'

   tmp0=weatherObj{_aNode.setFixedWeatherObj(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SequenceWeather'


sequenceWeather_eof returns [simulation._ast.ASTSequenceWeather ret = null] :
  tmp = sequenceWeather {$ret = $tmp.ret;} EOF ;


  sequenceWeather returns [simulation._ast.ASTSequenceWeather ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTSequenceWeather _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTSequenceWeather();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sequence'
(SEQUENCE)// End of 'ASTTerminal'

  (
  
   tmp0=weatherObj{addToIteratedAttributeIfNotNull(_aNode.getRandomWeatherObj(), _localctx.tmp0.ret);}  
  
  
)*
  (
  
   tmp1=unitNumber{_aNode.setSequenceDuration(_localctx.tmp1.ret);}  
  
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd RandomWeather'


randomWeather_eof returns [simulation._ast.ASTRandomWeather ret = null] :
  tmp = randomWeather {$ret = $tmp.ret;} EOF ;


  randomWeather returns [simulation._ast.ASTRandomWeather ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTRandomWeather _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTRandomWeather();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal random'
(RANDOM)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setRandomDuration(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Forecast'


forecast_eof returns [simulation._ast.ASTForecast ret = null] :
  tmp = forecast {$ret = $tmp.ret;} EOF ;


  forecast returns [simulation._ast.ASTForecast ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTForecast _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTForecast();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal forecast'
(FORECAST)// End of 'ASTTerminal'

   tmp0=weatherObj{_aNode.setForecastWeatherObj(_localctx.tmp0.ret);}  
  
   tmp1=unitNumber{_aNode.setForecastDuration(_localctx.tmp1.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Time'


time_eof returns [simulation._ast.ASTTime ret = null] :
  tmp = time {$ret = $tmp.ret;} EOF ;


  time returns [simulation._ast.ASTTime ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTTime _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTTime();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal time'
(TIME)// End of 'ASTTerminal'

  (
  
   tmp0=unitNumber{_aNode.setUnitNumber(_localctx.tmp0.ret);}  
  
  |
  (
  
  (tmp1=PosNum{_aNode.setTimeHours(convertPosNum($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp2=PosNum{_aNode.setTimeMinutes(convertPosNum($tmp2));}

  ) 
  
  
)
  |
  (
  
  (tmp3=PosNum{_aNode.setTimeHours(convertPosNum($tmp3));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp4=PosNum{_aNode.setTimeMinutes(convertPosNum($tmp4));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp5=PosNum{_aNode.setTimeSeconds(convertPosNum($tmp5));}

  ) 
  
  
)
  |
  (
  
  (tmp6=PosNum{_aNode.setTimeHours(convertPosNum($tmp6));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp7=PosNum{_aNode.setTimeMinutes(convertPosNum($tmp7));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp8=PosNum{_aNode.setTimeSeconds(convertPosNum($tmp8));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp9=PosNum{_aNode.setTimeMilliseconds(convertPosNum($tmp9));}

  ) 
  
  
)
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MapPath'


mapPath_eof returns [simulation._ast.ASTMapPath ret = null] :
  tmp = mapPath {$ret = $tmp.ret;} EOF ;


  mapPath returns [simulation._ast.ASTMapPath ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMapPath _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMapPath();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal map_path'
('map_path')// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setMapPath(convertName($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MapName'


mapName_eof returns [simulation._ast.ASTMapName ret = null] :
  tmp = mapName {$ret = $tmp.ret;} EOF ;


  mapName returns [simulation._ast.ASTMapName ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMapName _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMapName();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal map_name'
('map_name')// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setMapName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .osm'
('.osm')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MapHeight'


mapHeight_eof returns [simulation._ast.ASTMapHeight ret = null] :
  tmp = mapHeight {$ret = $tmp.ret;} EOF ;


  mapHeight returns [simulation._ast.ASTMapHeight ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMapHeight _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMapHeight();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal map_height'
('map_height')// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal flat'
(FLAT)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal random'
(RANDOM)// End of 'ASTTerminal'

  |
  (
  
  (tmp0=Name{_aNode.setHeightMap(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .hm'
('.hm')// End of 'ASTTerminal'

  
)
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MapOverlap'


mapOverlap_eof returns [simulation._ast.ASTMapOverlap ret = null] :
  tmp = mapOverlap {$ret = $tmp.ret;} EOF ;


  mapOverlap returns [simulation._ast.ASTMapOverlap ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMapOverlap _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMapOverlap();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal map_overlap'
('map_overlap')// End of 'ASTTerminal'

  (tmp0=PosNum{_aNode.setMapOverlap(convertPosNum($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MapSectorWidth'


mapSectorWidth_eof returns [simulation._ast.ASTMapSectorWidth ret = null] :
  tmp = mapSectorWidth {$ret = $tmp.ret;} EOF ;


  mapSectorWidth returns [simulation._ast.ASTMapSectorWidth ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMapSectorWidth _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMapSectorWidth();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal map_sector_width'
('map_sector_width')// End of 'ASTTerminal'

  (tmp0=PosNum{_aNode.setSectorWidth(convertPosNum($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MapSectorHeight'


mapSectorHeight_eof returns [simulation._ast.ASTMapSectorHeight ret = null] :
  tmp = mapSectorHeight {$ret = $tmp.ret;} EOF ;


  mapSectorHeight returns [simulation._ast.ASTMapSectorHeight ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMapSectorHeight _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMapSectorHeight();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal map_sector_height'
('map_sector_height')// End of 'ASTTerminal'

  (tmp0=PosNum{_aNode.setSectorHeight(convertPosNum($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MaxSectorUsers'


maxSectorUsers_eof returns [simulation._ast.ASTMaxSectorUsers ret = null] :
  tmp = maxSectorUsers {$ret = $tmp.ret;} EOF ;


  maxSectorUsers returns [simulation._ast.ASTMaxSectorUsers ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTMaxSectorUsers _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTMaxSectorUsers();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal max_sector_users'
('max_sector_users')// End of 'ASTTerminal'

  (tmp0=PosNum{_aNode.setMaxSectorUsers(convertPosNum($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Timeout'


timeout_eof returns [simulation._ast.ASTTimeout ret = null] :
  tmp = timeout {$ret = $tmp.ret;} EOF ;


  timeout returns [simulation._ast.ASTTimeout ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTTimeout _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTTimeout();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal timeout'
(TIMEOUT)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setTimeout(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Pedestrians'


pedestrians_eof returns [simulation._ast.ASTPedestrians ret = null] :
  tmp = pedestrians {$ret = $tmp.ret;} EOF ;


  pedestrians returns [simulation._ast.ASTPedestrians ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTPedestrians _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTPedestrians();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal <p>'
('<p>')// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp0=unitNumber{addToIteratedAttributeIfNotNull(_aNode.getStartX(), _localctx.tmp0.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=unitNumber{addToIteratedAttributeIfNotNull(_aNode.getStartY(), _localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ->'
(MINUSGT)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp2=unitNumber{addToIteratedAttributeIfNotNull(_aNode.getEndX(), _localctx.tmp2.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp3=unitNumber{addToIteratedAttributeIfNotNull(_aNode.getEndY(), _localctx.tmp3.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp4=unitNumber{addToIteratedAttributeIfNotNull(_aNode.getEndZ(), _localctx.tmp4.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)*
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd PedestrianDensity'


pedestrianDensity_eof returns [simulation._ast.ASTPedestrianDensity ret = null] :
  tmp = pedestrianDensity {$ret = $tmp.ret;} EOF ;


  pedestrianDensity returns [simulation._ast.ASTPedestrianDensity ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTPedestrianDensity _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTPedestrianDensity();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal pedestrian_density'
('pedestrian_density')// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setPedestrianDensity(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Vehicles'


vehicles_eof returns [simulation._ast.ASTVehicles ret = null] :
  tmp = vehicles {$ret = $tmp.ret;} EOF ;


  vehicles returns [simulation._ast.ASTVehicles ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTVehicles _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTVehicles();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
   tmp0=explicitVehicle{addToIteratedAttributeIfNotNull(_aNode.getExplicitVehicles(), _localctx.tmp0.ret);}  
  
  |
   tmp1=pathedVehicle{addToIteratedAttributeIfNotNull(_aNode.getPathedVehicles(), _localctx.tmp1.ret);}  
  
  |
   tmp2=randomVehicle{addToIteratedAttributeIfNotNull(_aNode.getRandomVehicles(), _localctx.tmp2.ret);}  
  
  
)*
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ExplicitVehicle'


explicitVehicle_eof returns [simulation._ast.ASTExplicitVehicle ret = null] :
  tmp = explicitVehicle {$ret = $tmp.ret;} EOF ;


  explicitVehicle returns [simulation._ast.ASTExplicitVehicle ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTExplicitVehicle _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTExplicitVehicle();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setVehicle(convertName($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp1=unitNumber{_aNode.setStartX(_localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp2=unitNumber{_aNode.setStartY(_localctx.tmp2.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp3=unitNumber{_aNode.setStartRot(_localctx.tmp3.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ->'
(MINUSGT)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp4=unitNumber{_aNode.setDestX(_localctx.tmp4.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp5=unitNumber{_aNode.setDestY(_localctx.tmp5.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp6=unitNumber{_aNode.setDestZ(_localctx.tmp6.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd PathedVehicle'


pathedVehicle_eof returns [simulation._ast.ASTPathedVehicle ret = null] :
  tmp = pathedVehicle {$ret = $tmp.ret;} EOF ;


  pathedVehicle returns [simulation._ast.ASTPathedVehicle ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTPathedVehicle _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTPathedVehicle();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal <v>'
('<v>')// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp0=unitNumber{_aNode.setSpawnX(_localctx.tmp0.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=unitNumber{_aNode.setSpawnY(_localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp2=unitNumber{_aNode.setSpawnRadius(_localctx.tmp2.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ->'
(MINUSGT)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp3=unitNumber{_aNode.setDestX(_localctx.tmp3.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp4=unitNumber{_aNode.setDestY(_localctx.tmp4.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp5=unitNumber{_aNode.setDestRadius(_localctx.tmp5.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  (
  
  (tmp6=PosNum{_aNode.setAmount(convertPosNum($tmp6));}

  ) 
  
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd RandomVehicle'


randomVehicle_eof returns [simulation._ast.ASTRandomVehicle ret = null] :
  tmp = randomVehicle {$ret = $tmp.ret;} EOF ;


  randomVehicle returns [simulation._ast.ASTRandomVehicle ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
simulation._ast.ASTRandomVehicle _aNode = null;
_aNode=simulation._ast.SimulationNodeFactory.createASTRandomVehicle();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal <v>'
('<v>')// End of 'ASTTerminal'

  (tmp0=PosNum{_aNode.setAmount(convertPosNum($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

   tmp1=unitNumber{_aNode.setStartX(_localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp2=unitNumber{_aNode.setStartY(_localctx.tmp2.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp3=unitNumber{_aNode.setDestX(_localctx.tmp3.ret);}  
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp4=unitNumber{_aNode.setDestY(_localctx.tmp4.ret);}  
  
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)?
  ;
  // End of 'ASTClassProd'


// Extra Rules for Interfaces
 
// Lexer symbols
  SNAIN : 'snain';
  ALTOSTRATUS : 'altostratus';
  SMOG : 'smog';
  LANDSPOUT : 'landspout';
  NONE : 'none';
  NIMBOSTRATUS : 'nimbostratus';
  STRATUS : 'stratus';
  STRATOCUMULUS : 'stratocumulus';
  MIRAGE : 'mirage';
  SIGHT : 'sight';
  WEATHER : 'weather';
  HUMIDITY : 'humidity';
  WATERSPOUT : 'waterspout';
  RAIN : 'rain';
  ALTOCUMULUS : 'altocumulus';
  CIRRUS : 'cirrus';
  LPAREN : '(';
  RPAREN : ')';
  FORECAST : 'forecast';
  PRESSURE : 'pressure';
  DRIZZLE : 'drizzle';
  COMMA : ',';
  WINDDIRECTION : 'winddirection';
  CIRROCUMULUS : 'cirrocumulus';
  RAINBOW : 'rainbow';
  SEQUENCE : 'sequence';
  MINUSGT : '->';
  CLOUDING : 'clouding';
  SNOW : 'snow';
  WINDSTRENGTH : 'windstrength';
  CIRROSTRATUS : 'cirrostratus';
  FIXED : 'fixed';
  COLON : ':';
  THUNDERSTORM : 'thunderstorm';
  FOG : 'fog';
  CONTRAILS : 'contrails';
  CUMULONIMBUS : 'cumulonimbus';
  TIMEOUT : 'timeout';
  RANDOM : 'random';
  SIM : 'sim';
  FLAT : 'flat';
  TEMPERATURE : 'temperature';
  SLEET : 'sleet';
  NOCTILUCENT : 'noctilucent';
  GRAUPEL : 'graupel';
  UNLIMITED : 'unlimited';
  GUSTNADO : 'gustnado';
  HAIL : 'hail';
  LCURLY : '{';
  TIME : 'time';
  RCURLY : '}';
 
// Lexer rules 
  
 // Start of 'ASTLexProd PosNum'
PosNum 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TElementType'
TElementType 
  
:
  
  (
  
  'Z' 
  |
  'Q' 
  |
  'C' 
  )

  (
   Space 
  )
*
  '(' 
  (
   Space 
  )
*
  (
  
   TUnitNumber 
  |
   TUnitInf 
  )

  (
   Space 
  )
*
  ':' 
  (
  
  (
   Space 
  )
*
   TUnitNumber 
  (
   Space 
  )
*
  ':' 
  )
?
  (
   Space 
  )
*
  (
  
   TUnitNumber 
  |
   TUnitInf 
  )

  (
   Space 
  )
*
  ')' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TFloatPointUnitNumber'
TFloatPointUnitNumber 
  
:
  
   Significant 
  (
  
  'e' 
  |
  'E' 
  )

  (
  
  '-' 
  |
  '+' 
  )

  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Significant'
fragment Significant 
  
:
  
  (
  
  '0'..'9'  
  )

  '.' 
  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd THexUnitNumber'
THexUnitNumber 
  
:
  
  '0x' 
  (
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitNumber'
TUnitNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
   Unit 
  (
  
  (
   Space 
  )
*
  (
  
  '*' 
  |
  '/' 
  )

   Unit 
  )
*
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitInf'
TUnitInf 
  
:
  
  (
  
  '-' 
  |
  '+' 
  )
?
  'o' 
  'o' 
  (
  
  (
   Space 
  )
+
   Unit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TComplexNumber'
TComplexNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
  (
  
  '+' 
  |
  '-' 
  )

  (
   Space 
  )
*
   PosNumber 
  'i' 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd RealNumber'
fragment RealNumber 
  
:
  
  (
  '-' 
  )
?
   PosNumber 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosNumber'
fragment PosNumber 
  
:
  
  (
  
   PosInt 
  (
   Space 
  )
*
  '/' 
  (
   Space 
  )
*
   PosInt 
  )

  |
  (
  
   PosInt 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  )

  |
  '0' 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosInt'
fragment PosInt 
  
:
  
   UngroupedPosInt 
  |
   GroupedPosInt 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UngroupedPosInt'
fragment UngroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd GroupedPosInt'
fragment GroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
?
  (
  
  '0'..'9'  
  )
?
  (
   PosIntGroup 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosIntGroup'
fragment PosIntGroup 
  
:
  
  '\'' 
  '0'..'9'  
  '0'..'9'  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Unit'
fragment Unit 
  
:
  
   SIUnit 
  |
   ImperialUnit 
  |
   OfficallyAcceptedUnit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ImperialUnit'
fragment ImperialUnit 
  
:
  
  'th' 
  |
  'in' 
  |
  'ft' 
  |
  'yd' 
  |
  'ch' 
  |
  'fur' 
  |
  'ml' 
  |
  'lea' 
  |
  'ftm' 
  |
  'fl oz' 
  |
  'gi' 
  |
  'pt' 
  |
  'qt' 
  |
  'gal' 
  |
  'gr' 
  |
  'dr' 
  |
  'oz' 
  |
  'lb' 
  |
  'st' 
  |
  'qr' 
  |
  'qtr' 
  |
  'cwt' 
  |
  'slug' 
  |
  'Â°F' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OfficallyAcceptedUnit'
fragment OfficallyAcceptedUnit 
  
:
  
  'min' 
  |
  'h' 
  |
  'd' 
  |
  'ha' 
  |
  'l' 
  |
  'L' 
  |
  't' 
  |
  'au' 
  |
  'AU' 
  |
  'Np' 
  |
  'B' 
  |
  'dB' 
  |
  'eV' 
  |
  'u' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SIUnit'
fragment SIUnit 
  
:
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  (
  
  (
  
  '/' 
  |
  '*' 
  )

  (
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  )

  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  )
*
  |
   SiUnitDimensionless 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnitPrefix'
fragment UnitPrefix 
  
:
  
  'Y' 
  |
  'Z' 
  |
  'E' 
  |
  'P' 
  |
  'T' 
  |
  'G' 
  |
  'M' 
  |
  'K' 
  |
  'k' 
  |
  'H' 
  |
  'da' 
  |
  'd' 
  |
  'c' 
  |
  'm' 
  |
  'n' 
  |
  'p' 
  |
  'f' 
  |
  'a' 
  |
  'z' 
  |
  'y' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitBaseDimension'
fragment SiUnitBaseDimension 
  
:
  
  'm' 
  |
  'g' 
  |
  's' 
  |
  'A' 
  |
  'K' 
  |
  'mol' 
  |
  'cd' 
  |
  'Hz' 
  |
  'N' 
  |
  'Pa' 
  |
  'J' 
  |
  'W' 
  |
  'C' 
  |
  'V' 
  |
  'F' 
  |
  'Î©' 
  |
  'S' 
  |
  'Wb' 
  |
  'T' 
  |
  'H' 
  |
  'Â°C' 
  |
  'lm' 
  |
  'lx' 
  |
  'Bq' 
  |
  'Gy' 
  |
  'Sv' 
  |
  'kat' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitDimensionless'
fragment SiUnitDimensionless 
  
:
  
  'rad' 
  |
  'sr' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Space'
fragment Space 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NamePart'
fragment NamePart 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  (
   NamePart 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  (
  
  '\n' 
  |
  '\r' 
  (
  
  '\n' 
  )
?
  )
?
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Numb'
Numb 
  
:
  
  (
  
  '0' 
  |
  (
  
  '1'..'9'  
  )
+
  (
  
  '0'..'9'  
  )
*
  )

  ;// End of 'ASTLexProd'


