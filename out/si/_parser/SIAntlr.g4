/* generated by template parser.Parser*/

// Generated antlr file

// Parser header
/* generated by template parser.ParserHeader*/
grammar SIAntlr;
@parser::header {
package si._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package si._parser;
}
options {
superClass=MCParser;
}

@parser::members

{
// Global actions

// Convert functions
  // convert function for TFloatPointUnitNumber
private String convertTFloatPointUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for Significant
private String convertSignificant(Token t)  {
    return t.getText();
}

  // convert function for THexUnitNumber
private String convertTHexUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitNumber
private String convertTUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitInf
private String convertTUnitInf(Token t)  {
    return t.getText();
}

  // convert function for TComplexNumber
private String convertTComplexNumber(Token t)  {
    return t.getText();
}

  // convert function for RealNumber
private String convertRealNumber(Token t)  {
    return t.getText();
}

  // convert function for PosNumber
private String convertPosNumber(Token t)  {
    return t.getText();
}

  // convert function for PosInt
private String convertPosInt(Token t)  {
    return t.getText();
}

  // convert function for UngroupedPosInt
private String convertUngroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for GroupedPosInt
private String convertGroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for PosIntGroup
private String convertPosIntGroup(Token t)  {
    return t.getText();
}

  // convert function for Unit
private String convertUnit(Token t)  {
    return t.getText();
}

  // convert function for ImperialUnit
private String convertImperialUnit(Token t)  {
    return t.getText();
}

  // convert function for OfficallyAcceptedUnit
private String convertOfficallyAcceptedUnit(Token t)  {
    return t.getText();
}

  // convert function for SIUnit
private String convertSIUnit(Token t)  {
    return t.getText();
}

  // convert function for UnitPrefix
private String convertUnitPrefix(Token t)  {
    return t.getText();
}

  // convert function for SiUnitBaseDimension
private String convertSiUnitBaseDimension(Token t)  {
    return t.getText();
}

  // convert function for SiUnitDimensionless
private String convertSiUnitDimensionless(Token t)  {
    return t.getText();
}

  // convert function for Space
private String convertSpace(Token t)  {
    return t.getText();
}

  // convert function for NamePart
private String convertNamePart(Token t)  {
    return t.getText();
}

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

}

// Lexer header
/* generated by template parser.LexerMember*/


@lexer::members {

// Add additional Java Code to lexer

private de.monticore.antlr4.MCParser _monticore_parser;
protected de.monticore.antlr4.MCParser getCompiler() {
   return _monticore_parser;
}
public void setMCParser(de.monticore.antlr4.MCParser in) {
  this._monticore_parser = in;
}
}


// Global actions

// Parser rules 
  
 // Start of 'ASTClassProd Number'


number_eof returns [si._ast.ASTNumber ret = null] :
  tmp = number {$ret = $tmp.ret;} EOF ;


  number returns [si._ast.ASTNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=floatPointUnitNumber{_aNode.setFloatPointUnitNumber(_localctx.tmp0.ret);}  
  
  |
   tmp1=hexUnitNumber{_aNode.setHexUnitNumber(_localctx.tmp1.ret);}  
  
  |
   tmp2=complexNumber{_aNode.setComplexNumber(_localctx.tmp2.ret);}  
  
  |
   tmp3=unitNumber{_aNode.setUnitNumber(_localctx.tmp3.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd FloatPointUnitNumber'


floatPointUnitNumber_eof returns [si._ast.ASTFloatPointUnitNumber ret = null] :
  tmp = floatPointUnitNumber {$ret = $tmp.ret;} EOF ;


  floatPointUnitNumber returns [si._ast.ASTFloatPointUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTFloatPointUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTFloatPointUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TFloatPointUnitNumber{_aNode.setTFloatPointUnitNumber(convertTFloatPointUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd HexUnitNumber'


hexUnitNumber_eof returns [si._ast.ASTHexUnitNumber ret = null] :
  tmp = hexUnitNumber {$ret = $tmp.ret;} EOF ;


  hexUnitNumber returns [si._ast.ASTHexUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTHexUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTHexUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=THexUnitNumber{_aNode.setTHexUnitNumber(convertTHexUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd UnitNumber'


unitNumber_eof returns [si._ast.ASTUnitNumber ret = null] :
  tmp = unitNumber {$ret = $tmp.ret;} EOF ;


  unitNumber returns [si._ast.ASTUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTUnitNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TUnitNumber{_aNode.setTUnitNumber(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexNumber'


complexNumber_eof returns [si._ast.ASTComplexNumber ret = null] :
  tmp = complexNumber {$ret = $tmp.ret;} EOF ;


  complexNumber returns [si._ast.ASTComplexNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
si._ast.ASTComplexNumber _aNode = null;
_aNode=si._ast.SINodeFactory.createASTComplexNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TComplexNumber{_aNode.setTComplexNumber(convertTComplexNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'


// Extra Rules for Interfaces
 
// Lexer symbols
 
// Lexer rules 
  
 // Start of 'ASTLexProd TFloatPointUnitNumber'
TFloatPointUnitNumber 
  
:
  
   Significant 
  (
  
  'e' 
  |
  'E' 
  )

  (
  
  '-' 
  |
  '+' 
  )

  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Significant'
fragment Significant 
  
:
  
  (
  
  '0'..'9'  
  )

  '.' 
  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd THexUnitNumber'
THexUnitNumber 
  
:
  
  '0x' 
  (
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitNumber'
TUnitNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
   Unit 
  (
  
  (
   Space 
  )
*
  (
  
  '*' 
  |
  '/' 
  )

   Unit 
  )
*
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitInf'
TUnitInf 
  
:
  
  (
  
  '-' 
  |
  '+' 
  )
?
  'o' 
  'o' 
  (
  
  (
   Space 
  )
+
   Unit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TComplexNumber'
TComplexNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
  (
  
  '+' 
  |
  '-' 
  )

  (
   Space 
  )
*
   PosNumber 
  'i' 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd RealNumber'
fragment RealNumber 
  
:
  
  (
  '-' 
  )
?
   PosNumber 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosNumber'
fragment PosNumber 
  
:
  
  (
  
   PosInt 
  (
   Space 
  )
*
  '/' 
  (
   Space 
  )
*
   PosInt 
  )

  |
  (
  
   PosInt 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  )

  |
  '0' 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosInt'
fragment PosInt 
  
:
  
   UngroupedPosInt 
  |
   GroupedPosInt 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UngroupedPosInt'
fragment UngroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd GroupedPosInt'
fragment GroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
?
  (
  
  '0'..'9'  
  )
?
  (
   PosIntGroup 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosIntGroup'
fragment PosIntGroup 
  
:
  
  '\'' 
  '0'..'9'  
  '0'..'9'  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Unit'
fragment Unit 
  
:
  
   SIUnit 
  |
   ImperialUnit 
  |
   OfficallyAcceptedUnit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ImperialUnit'
fragment ImperialUnit 
  
:
  
  'th' 
  |
  'in' 
  |
  'ft' 
  |
  'yd' 
  |
  'ch' 
  |
  'fur' 
  |
  'ml' 
  |
  'lea' 
  |
  'ftm' 
  |
  'fl oz' 
  |
  'gi' 
  |
  'pt' 
  |
  'qt' 
  |
  'gal' 
  |
  'gr' 
  |
  'dr' 
  |
  'oz' 
  |
  'lb' 
  |
  'st' 
  |
  'qr' 
  |
  'qtr' 
  |
  'cwt' 
  |
  'slug' 
  |
  '°F' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OfficallyAcceptedUnit'
fragment OfficallyAcceptedUnit 
  
:
  
  'min' 
  |
  'h' 
  |
  'd' 
  |
  'ha' 
  |
  'l' 
  |
  'L' 
  |
  't' 
  |
  'au' 
  |
  'AU' 
  |
  'Np' 
  |
  'B' 
  |
  'dB' 
  |
  'eV' 
  |
  'u' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SIUnit'
fragment SIUnit 
  
:
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  (
  
  (
  
  '/' 
  |
  '*' 
  )

  (
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  )

  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  )
*
  |
   SiUnitDimensionless 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnitPrefix'
fragment UnitPrefix 
  
:
  
  'Y' 
  |
  'Z' 
  |
  'E' 
  |
  'P' 
  |
  'T' 
  |
  'G' 
  |
  'M' 
  |
  'K' 
  |
  'k' 
  |
  'H' 
  |
  'da' 
  |
  'd' 
  |
  'c' 
  |
  'm' 
  |
  'n' 
  |
  'p' 
  |
  'f' 
  |
  'a' 
  |
  'z' 
  |
  'y' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitBaseDimension'
fragment SiUnitBaseDimension 
  
:
  
  'm' 
  |
  'g' 
  |
  's' 
  |
  'A' 
  |
  'K' 
  |
  'mol' 
  |
  'cd' 
  |
  'Hz' 
  |
  'N' 
  |
  'Pa' 
  |
  'J' 
  |
  'W' 
  |
  'C' 
  |
  'V' 
  |
  'F' 
  |
  'Ω' 
  |
  'S' 
  |
  'Wb' 
  |
  'T' 
  |
  'H' 
  |
  '°C' 
  |
  'lm' 
  |
  'lx' 
  |
  'Bq' 
  |
  'Gy' 
  |
  'Sv' 
  |
  'kat' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitDimensionless'
fragment SiUnitDimensionless 
  
:
  
  'rad' 
  |
  'sr' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Space'
fragment Space 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NamePart'
fragment NamePart 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  (
   NamePart 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  (
  
  '\n' 
  |
  '\r' 
  (
  
  '\n' 
  )
?
  )
?
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'


