/* generated by template parser.Parser*/

// Generated antlr file

// Parser header
/* generated by template parser.ParserHeader*/
grammar WeatherAntlr;
@parser::header {
package weather._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package weather._parser;
}
options {
superClass=MCParser;
}

@parser::members

{
// Global actions

// Convert functions
  // convert function for TFloatPointUnitNumber
private String convertTFloatPointUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for Significant
private String convertSignificant(Token t)  {
    return t.getText();
}

  // convert function for THexUnitNumber
private String convertTHexUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitNumber
private String convertTUnitNumber(Token t)  {
    return t.getText();
}

  // convert function for TUnitInf
private String convertTUnitInf(Token t)  {
    return t.getText();
}

  // convert function for TComplexNumber
private String convertTComplexNumber(Token t)  {
    return t.getText();
}

  // convert function for RealNumber
private String convertRealNumber(Token t)  {
    return t.getText();
}

  // convert function for PosNumber
private String convertPosNumber(Token t)  {
    return t.getText();
}

  // convert function for PosInt
private String convertPosInt(Token t)  {
    return t.getText();
}

  // convert function for UngroupedPosInt
private String convertUngroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for GroupedPosInt
private String convertGroupedPosInt(Token t)  {
    return t.getText();
}

  // convert function for PosIntGroup
private String convertPosIntGroup(Token t)  {
    return t.getText();
}

  // convert function for Unit
private String convertUnit(Token t)  {
    return t.getText();
}

  // convert function for ImperialUnit
private String convertImperialUnit(Token t)  {
    return t.getText();
}

  // convert function for SIUnit
private String convertSIUnit(Token t)  {
    return t.getText();
}

  // convert function for UnitPrefix
private String convertUnitPrefix(Token t)  {
    return t.getText();
}

  // convert function for OfficallyAcceptedUnit
private String convertOfficallyAcceptedUnit(Token t)  {
    return t.getText();
}

  // convert function for SiUnitBaseDimension
private String convertSiUnitBaseDimension(Token t)  {
    return t.getText();
}

  // convert function for SiUnitDimensionless
private String convertSiUnitDimensionless(Token t)  {
    return t.getText();
}

  // convert function for Space
private String convertSpace(Token t)  {
    return t.getText();
}

  // convert function for NamePart
private String convertNamePart(Token t)  {
    return t.getText();
}

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

}

// Lexer header
/* generated by template parser.LexerMember*/


@lexer::members {

// Add additional Java Code to lexer

private de.monticore.antlr4.MCParser _monticore_parser;
protected de.monticore.antlr4.MCParser getCompiler() {
   return _monticore_parser;
}
public void setMCParser(de.monticore.antlr4.MCParser in) {
  this._monticore_parser = in;
}
}


// Global actions

// Parser rules 
  
 // Start of 'ASTClassProd Number'


number_eof returns [numberunit._ast.ASTNumber ret = null] :
  tmp = number {$ret = $tmp.ret;} EOF ;


  number returns [numberunit._ast.ASTNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
numberunit._ast.ASTNumber _aNode = null;
_aNode=numberunit._ast.NumberUnitNodeFactory.createASTNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=floatPointUnitNumber{_aNode.setFloatPointUnitNumber(_localctx.tmp0.ret);}  
  
  |
   tmp1=hexUnitNumber{_aNode.setHexUnitNumber(_localctx.tmp1.ret);}  
  
  |
   tmp2=complexNumber{_aNode.setComplexNumber(_localctx.tmp2.ret);}  
  
  |
   tmp3=unitNumber{_aNode.setUnitNumber(_localctx.tmp3.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd FloatPointUnitNumber'


floatPointUnitNumber_eof returns [numberunit._ast.ASTFloatPointUnitNumber ret = null] :
  tmp = floatPointUnitNumber {$ret = $tmp.ret;} EOF ;


  floatPointUnitNumber returns [numberunit._ast.ASTFloatPointUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
numberunit._ast.ASTFloatPointUnitNumber _aNode = null;
_aNode=numberunit._ast.NumberUnitNodeFactory.createASTFloatPointUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TFloatPointUnitNumber{_aNode.setTFloatPointUnitNumber(convertTFloatPointUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd HexUnitNumber'


hexUnitNumber_eof returns [numberunit._ast.ASTHexUnitNumber ret = null] :
  tmp = hexUnitNumber {$ret = $tmp.ret;} EOF ;


  hexUnitNumber returns [numberunit._ast.ASTHexUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
numberunit._ast.ASTHexUnitNumber _aNode = null;
_aNode=numberunit._ast.NumberUnitNodeFactory.createASTHexUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=THexUnitNumber{_aNode.setTHexUnitNumber(convertTHexUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd UnitNumber'


unitNumber_eof returns [numberunit._ast.ASTUnitNumber ret = null] :
  tmp = unitNumber {$ret = $tmp.ret;} EOF ;


  unitNumber returns [numberunit._ast.ASTUnitNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
numberunit._ast.ASTUnitNumber _aNode = null;
_aNode=numberunit._ast.NumberUnitNodeFactory.createASTUnitNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TUnitNumber{_aNode.setTUnitNumber(convertTUnitNumber($tmp0));}

  ) 
  
  |
  (tmp1=TUnitInf{_aNode.setTUnitInf(convertTUnitInf($tmp1));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexNumber'


complexNumber_eof returns [numberunit._ast.ASTComplexNumber ret = null] :
  tmp = complexNumber {$ret = $tmp.ret;} EOF ;


  complexNumber returns [numberunit._ast.ASTComplexNumber ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
numberunit._ast.ASTComplexNumber _aNode = null;
_aNode=numberunit._ast.NumberUnitNodeFactory.createASTComplexNumber();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=TComplexNumber{_aNode.setTComplexNumber(convertTComplexNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Temperature'


temperature_eof returns [weather._ast.ASTTemperature ret = null] :
  tmp = temperature {$ret = $tmp.ret;} EOF ;


  temperature returns [weather._ast.ASTTemperature ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTTemperature _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTTemperature();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal temperature'
(TEMPERATURE)// End of 'ASTTerminal'

  (tmp0=TUnitNumber{_aNode.setWeatherTemperature(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Humidity'


humidity_eof returns [weather._ast.ASTHumidity ret = null] :
  tmp = humidity {$ret = $tmp.ret;} EOF ;


  humidity returns [weather._ast.ASTHumidity ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTHumidity _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTHumidity();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal humidity'
(HUMIDITY)// End of 'ASTTerminal'

  (tmp0=TUnitNumber{_aNode.setWeatherHumidity(convertTUnitNumber($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTConstantGroup'
PERCENT{
_aNode.setPERCENT(true);
}// End of 'ASTConstantGroup'

  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Pressure'


pressure_eof returns [weather._ast.ASTPressure ret = null] :
  tmp = pressure {$ret = $tmp.ret;} EOF ;


  pressure returns [weather._ast.ASTPressure ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPressure _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPressure();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal pressure'
(PRESSURE)// End of 'ASTTerminal'

  (tmp0=TUnitNumber{_aNode.setWeatherPressure(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Windstrength'


windstrength_eof returns [weather._ast.ASTWindstrength ret = null] :
  tmp = windstrength {$ret = $tmp.ret;} EOF ;


  windstrength returns [weather._ast.ASTWindstrength ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWindstrength _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWindstrength();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal windstrength'
(WINDSTRENGTH)// End of 'ASTTerminal'

  (tmp0=TUnitNumber{_aNode.setWeatherWindstrength(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Winddirection'


winddirection_eof returns [weather._ast.ASTWinddirection ret = null] :
  tmp = winddirection {$ret = $tmp.ret;} EOF ;


  winddirection returns [weather._ast.ASTWinddirection ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWinddirection _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWinddirection();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal winddirection'
(WINDDIRECTION)// End of 'ASTTerminal'

  (tmp0=TUnitNumber{_aNode.setWeatherWinddirection(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Precipitationtype'


precipitationtype_eof returns [weather._ast.ASTPrecipitationtype ret = null] :
  tmp = precipitationtype {$ret = $tmp.ret;} EOF ;


  precipitationtype returns [weather._ast.ASTPrecipitationtype ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPrecipitationtype _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPrecipitationtype();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal precipitation_type'
('precipitation_type')// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(NONE{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.NONE);
}|
DRIZZLE{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.DRIZZLE);
}|
RAIN{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.RAIN);
}|
'freezing drizzle'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT0);
}|
'freezing rain'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT1);
}|
'snow rain'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT2);
}|
SNAIN{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.SNAIN);
}|
SNOW{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.SNOW);
}|
'snow_grains'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT3);
}|
'ice_pellets'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT4);
}|
SLEET{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.SLEET);
}|
HAIL{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.HAIL);
}|
'snow_pellets'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT5);
}|
GRAUPEL{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.GRAUPEL);
}|
'ice_crystals'{
_aNode.setPrecipitationType(weather._ast.ASTConstantsWeather.CONSTANT6);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Precipitationamount'


precipitationamount_eof returns [weather._ast.ASTPrecipitationamount ret = null] :
  tmp = precipitationamount {$ret = $tmp.ret;} EOF ;


  precipitationamount returns [weather._ast.ASTPrecipitationamount ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTPrecipitationamount _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTPrecipitationamount();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal precipitation_amount'
('precipitation_amount')// End of 'ASTTerminal'

  (tmp0=TUnitNumber{_aNode.setWeatherPrecipitationamount(convertTUnitNumber($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Clouding'


clouding_eof returns [weather._ast.ASTClouding ret = null] :
  tmp = clouding {$ret = $tmp.ret;} EOF ;


  clouding returns [weather._ast.ASTClouding ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTClouding _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTClouding();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal clouding'
(CLOUDING)// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(NONE{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.NONE);
}|
CIRROSTRATUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CIRROSTRATUS);
}|
ALTOSTRATUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.ALTOSTRATUS);
}|
STRATUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.STRATUS);
}|
NIMBOSTRATUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.NIMBOSTRATUS);
}|
NOCTILUCENT{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.NOCTILUCENT);
}|
'polar stratospheric'{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CONSTANT7);
}|
CIRRUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CIRRUS);
}|
CIRROCUMULUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CIRROCUMULUS);
}|
ALTOCUMULUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.ALTOCUMULUS);
}|
STRATOCUMULUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.STRATOCUMULUS);
}|
'cumulus_humilis'{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CONSTANT8);
}|
'cumulus_mediocris'{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CONSTANT9);
}|
'cumulus_congestus'{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CONSTANT10);
}|
CUMULONIMBUS{
_aNode.setCloudingType(weather._ast.ASTConstantsWeather.CUMULONIMBUS);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Sight'


sight_eof returns [weather._ast.ASTSight ret = null] :
  tmp = sight {$ret = $tmp.ret;} EOF ;


  sight returns [weather._ast.ASTSight ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTSight _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTSight();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal sight'
(SIGHT)// End of 'ASTTerminal'

  (
  
  (tmp0=TUnitNumber{_aNode.setWeatherSight(convertTUnitNumber($tmp0));}

  ) 
  
  |
  
 // Start of 'ASTConstantGroup'
UNLIMITED{
_aNode.setUnlimited(true);
}// End of 'ASTConstantGroup'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd WeatherPhenomena'


weatherPhenomena_eof returns [weather._ast.ASTWeatherPhenomena ret = null] :
  tmp = weatherPhenomena {$ret = $tmp.ret;} EOF ;


  weatherPhenomena returns [weather._ast.ASTWeatherPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTWeatherPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTWeatherPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal weather_phenomena'
('weather_phenomena')// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(FOG{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.FOG);
}|
'rope_tornado'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT11);
}|
'cone_tornado'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT12);
}|
'wedge_tornado'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT13);
}|
'multi-vortex_tornado'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT14);
}|
LANDSPOUT{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.LANDSPOUT);
}|
WATERSPOUT{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.WATERSPOUT);
}|
GUSTNADO{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.GUSTNADO);
}|
'dust_devil'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT15);
}|
'steam_devil'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT16);
}|
THUNDERSTORM{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.THUNDERSTORM);
})// End of 'ASTConstantGroup'

  (
  
  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

  (
  
  (tmp0=TUnitNumber{_aNode.setPosX(convertTUnitNumber($tmp0));}

  ) 
  
  
)
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

  (
  
  (tmp1=TUnitNumber{_aNode.setPosY(convertTUnitNumber($tmp1));}

  ) 
  
  
)
  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)?
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd OpticalPhenomena'


opticalPhenomena_eof returns [weather._ast.ASTOpticalPhenomena ret = null] :
  tmp = opticalPhenomena {$ret = $tmp.ret;} EOF ;


  opticalPhenomena returns [weather._ast.ASTOpticalPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTOpticalPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTOpticalPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal optical_phenomena'
('optical_phenomena')// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(RAINBOW{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.RAINBOW);
}|
'northern_lights'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT17);
}|
'circumzenithal_arc'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT18);
}|
'zodiacal_light'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT19);
}|
'crepuscular_rays'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT20);
}|
MIRAGE{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.MIRAGE);
}|
'fog_bow'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT21);
})// End of 'ASTConstantGroup'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ArtificialPhenomena'


artificialPhenomena_eof returns [weather._ast.ASTArtificialPhenomena ret = null] :
  tmp = artificialPhenomena {$ret = $tmp.ret;} EOF ;


  artificialPhenomena returns [weather._ast.ASTArtificialPhenomena ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
weather._ast.ASTArtificialPhenomena _aNode = null;
_aNode=weather._ast.WeatherNodeFactory.createASTArtificialPhenomena();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal artificial_phenomena'
('artificial_phenomena')// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(CONTRAILS{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONTRAILS);
}|
SMOG{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.SMOG);
}|
'rocket_exhaust_trails'{
_aNode.setPhenomenaType(weather._ast.ASTConstantsWeather.CONSTANT22);
})// End of 'ASTConstantGroup'

  
)
  ;
  // End of 'ASTClassProd'


// Extra Rules for Interfaces
 
// Lexer symbols
  CONTRAILS : 'contrails';
  SNAIN : 'snain';
  ALTOSTRATUS : 'altostratus';
  SMOG : 'smog';
  LANDSPOUT : 'landspout';
  NONE : 'none';
  NIMBOSTRATUS : 'nimbostratus';
  CUMULONIMBUS : 'cumulonimbus';
  STRATUS : 'stratus';
  STRATOCUMULUS : 'stratocumulus';
  MIRAGE : 'mirage';
  TEMPERATURE : 'temperature';
  SIGHT : 'sight';
  HUMIDITY : 'humidity';
  WATERSPOUT : 'waterspout';
  SLEET : 'sleet';
  NOCTILUCENT : 'noctilucent';
  GRAUPEL : 'graupel';
  RAIN : 'rain';
  ALTOCUMULUS : 'altocumulus';
  PERCENT : '%';
  UNLIMITED : 'unlimited';
  CIRRUS : 'cirrus';
  GUSTNADO : 'gustnado';
  LPAREN : '(';
  RPAREN : ')';
  PRESSURE : 'pressure';
  DRIZZLE : 'drizzle';
  HAIL : 'hail';
  COMMA : ',';
  WINDDIRECTION : 'winddirection';
  CIRROCUMULUS : 'cirrocumulus';
  RAINBOW : 'rainbow';
  CLOUDING : 'clouding';
  SNOW : 'snow';
  WINDSTRENGTH : 'windstrength';
  CIRROSTRATUS : 'cirrostratus';
  THUNDERSTORM : 'thunderstorm';
  FOG : 'fog';
 
// Lexer rules 
  
 // Start of 'ASTLexProd TFloatPointUnitNumber'
TFloatPointUnitNumber 
  
:
  
   Significant 
  (
  
  'e' 
  |
  'E' 
  )

  (
  
  '-' 
  |
  '+' 
  )

  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Significant'
fragment Significant 
  
:
  
  (
  
  '0'..'9'  
  )

  '.' 
  (
  
  '0'..'9'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd THexUnitNumber'
THexUnitNumber 
  
:
  
  '0x' 
  (
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitNumber'
TUnitNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
   Unit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TUnitInf'
TUnitInf 
  
:
  
  (
  
  '-' 
  |
  '+' 
  )
?
  'o' 
  'o' 
  (
  
  (
   Space 
  )
+
   Unit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd TComplexNumber'
TComplexNumber 
  
:
  
   RealNumber 
  (
  
  (
   Space 
  )
*
  (
  
  '+' 
  |
  '-' 
  )

  (
   Space 
  )
*
   PosNumber 
  'i' 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd RealNumber'
fragment RealNumber 
  
:
  
  (
  '-' 
  )
?
   PosNumber 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosNumber'
fragment PosNumber 
  
:
  
  (
  
   PosInt 
  (
   Space 
  )
*
  '/' 
  (
   Space 
  )
*
   PosInt 
  )

  |
  (
  
   PosInt 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  )

  |
  '0' 
  (
  
  '.' 
  (
  
  '0'..'9'  
  )
+
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosInt'
fragment PosInt 
  
:
  
   UngroupedPosInt 
  |
   GroupedPosInt 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UngroupedPosInt'
fragment UngroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd GroupedPosInt'
fragment GroupedPosInt 
  
:
  
  (
  
  '1'..'9'  
  )

  (
  
  '0'..'9'  
  )
?
  (
  
  '0'..'9'  
  )
?
  (
   PosIntGroup 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd PosIntGroup'
fragment PosIntGroup 
  
:
  
  '\'' 
  '0'..'9'  
  '0'..'9'  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Unit'
fragment Unit 
  
:
  
   SIUnit 
  |
   ImperialUnit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ImperialUnit'
fragment ImperialUnit 
  
:
  
  'th' 
  |
  'in' 
  |
  'ft' 
  |
  'yd' 
  |
  'ch' 
  |
  'fur' 
  |
  'ml' 
  |
  'lea' 
  |
  'ftm' 
  |
  'fl oz' 
  |
  'gi' 
  |
  'pt' 
  |
  'qt' 
  |
  'gal' 
  |
  'gr' 
  |
  'dr' 
  |
  'oz' 
  |
  'lb' 
  |
  'st' 
  |
  'qr' 
  |
  'qtr' 
  |
  'cwt' 
  |
  'slug' 
  |
  '\u00B0F' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SIUnit'
fragment SIUnit 
  
:
  
  (
  
  (
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  )

  |
   OfficallyAcceptedUnit 
  )

  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  (
  
  (
  
  '/' 
  |
  '*' 
  )

  (
  
  (
  
  (
   UnitPrefix 
  )
?
   SiUnitBaseDimension 
  )

  |
   OfficallyAcceptedUnit 
  )

  (
  
  '^' 
  (
  '-' 
  )
?
  '0'..'9'  
  )
?
  )
*
  |
   SiUnitDimensionless 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnitPrefix'
fragment UnitPrefix 
  
:
  
  'Y' 
  |
  'Z' 
  |
  'E' 
  |
  'P' 
  |
  'T' 
  |
  'G' 
  |
  'M' 
  |
  'K' 
  |
  'k' 
  |
  'H' 
  |
  'da' 
  |
  'd' 
  |
  'c' 
  |
  'm' 
  |
  'n' 
  |
  'p' 
  |
  'f' 
  |
  'a' 
  |
  'z' 
  |
  'y' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OfficallyAcceptedUnit'
fragment OfficallyAcceptedUnit 
  
:
  
  'min' 
  |
  'h' 
  |
  'd' 
  |
  '\u00B0' 
  |
  'ha' 
  |
  'l' 
  |
  'L' 
  |
  'au' 
  |
  'AU' 
  |
  'Np' 
  |
  'B' 
  |
  'dB' 
  |
  'eV' 
  |
  'u' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitBaseDimension'
fragment SiUnitBaseDimension 
  
:
  
  'm' 
  |
  'g' 
  |
  's' 
  |
  'A' 
  |
  'K' 
  |
  'mol' 
  |
  'cd' 
  |
  'Hz' 
  |
  'N' 
  |
  'Pa' 
  |
  'J' 
  |
  'W' 
  |
  'C' 
  |
  'V' 
  |
  'F' 
  |
  'Î©' 
  |
  'S' 
  |
  'Wb' 
  |
  'T' 
  |
  'H' 
  |
  '\u00B0C' 
  |
  'lm' 
  |
  'lx' 
  |
  'Bq' 
  |
  'Gy' 
  |
  'Sv' 
  |
  'kat' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SiUnitDimensionless'
fragment SiUnitDimensionless 
  
:
  
  'rad' 
  |
  'sr' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Space'
fragment Space 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NamePart'
fragment NamePart 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'n'  
  |
  'p'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )

  |
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

   NamePart 
  (
   NamePart 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  (
  
  '\n' 
  |
  '\r' 
  (
  
  '\n' 
  )
?
  )
?
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {_channel=HIDDEN;
if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
  _comment.set_SourcePositionStart(new de.se_rwth.commons.SourcePosition(getLine(), getCharPositionInLine()));
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(getToken()));
  getCompiler().addComment(_comment);
}

};// End of 'ASTLexProd'


